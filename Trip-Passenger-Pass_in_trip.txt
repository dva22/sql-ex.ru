/***
Схема БД состоит из четырех отношений:
Company (ID_comp, name)
Trip(trip_no, ID_comp, plane, town_from, town_to, time_out, time_in)
Passenger(ID_psg, name)
Pass_in_trip(trip_no, date, ID_psg, place)
Таблица Company содержит идентификатор и название компании, осуществляющей перевозку пассажиров. Таблица Trip содержит информацию о рейсах: номер рейса, идентификатор компании, тип самолета, город отправления, город прибытия, время отправления и время прибытия. Таблица Passenger содержит идентификатор и имя пассажира. Таблица Pass_in_trip содержит информацию о полетах: номер рейса, дата вылета (день), идентификатор пассажира и место, на котором он сидел во время полета. При этом следует иметь в виду, что
- рейсы выполняются ежедневно, а длительность полета любого рейса менее суток; town_from <> town_to;
- время и дата учитывается относительно одного часового пояса;
- время отправления и прибытия указывается с точностью до минуты;
- среди пассажиров могут быть однофамильцы (одинаковые значения поля name, например, Bruce Willis);
- номер места в салоне – это число с буквой; число определяет номер ряда, буква (a – d) – место в ряду слева направо в алфавитном порядке;
- связи и ограничения показаны на схеме данных.***/

/***
Задание: 76 (Serge I: 2003-08-28)
Определить время, проведенное в полетах, для пассажиров, летавших всегда на разных местах. Вывод: имя пассажира, время в минутах.


WITH dsPsg AS
(SELECT pt.Id_psg id
FROM Pass_in_trip pt, Trip t
WHERE t.trip_no = pt.trip_no 
GROUP BY pt.Id_psg
HAVING COUNT(DISTINCT pt.place) = COUNT(pt.place)
),
dsTime AS
(SELECT pt.Id_psg id, 
        sum(DATEDIFF(minute, time_out, DATEADD(DAY,IIF(time_in<time_out,1,0)
                     ,time_in))
           ) dur 
 FROM Pass_in_trip pt, Trip t
 WHERE t.trip_no = pt.trip_no 
 GROUP BY pt.Id_psg
)
SELECT p.name, dsTime.dur
FROM dsPsg, Passenger p, dsTime
WHERE p.ID_psg = dsPsg.id and
      dsTime.id = p.ID_psg

Задание: 88 (Serge I: 2003-04-29)
Среди тех, кто пользуется услугами только одной компании, определить имена разных пассажиров, летавших чаще других. 
Вывести: имя пассажира, число полетов и название компании.
WITH dsPsg AS
(SELECT p.ID_psg,
        COUNT(DISTINCT t.ID_comp) countComp,
        COUNT(*) trip_Qty,
        max(t.ID_comp) idComp
 FROM Trip t, Pass_in_trip p
 WHERE p.trip_no = t.trip_no
 GROUP BY p.ID_psg
 HAVING COUNT(DISTINCT t.ID_comp) = 1
)
SELECT p.name, dsPsg.trip_Qty, c.name
FROM dsPsg, Company c, Passenger p
WHERE dsPsg.ID_psg = p.ID_psg and
      dsPsg.idComp = c.ID_Comp and
      dsPsg.trip_Qty = (SELECT max(dsPsg.trip_Qty)
                        FROM dsPsg
                       )

Задание: 87 (Serge I: 2003-08-28)
Считая, что пункт самого первого вылета пассажира является местом жительства, найти не москвичей, которые прилетали в Москву более одного раза. 
Вывод: имя пассажира, количество полетов в Москву
WITH dsFirst AS
(SELECT p.ID_psg, min(date + time_out) date
 FROM Pass_in_trip p, Trip t
 WHERE t.trip_no = p.trip_no
 GROUP BY p.ID_psg
),
dsFirstM AS
(SELECT p.ID_psg
FROM dsFirst, Pass_in_trip p, Trip t
WHERE dsFirst.date = (p.date + time_out) and 
      dsFirst.ID_psg = p.ID_psg and 
      t.trip_no = p.trip_no and
      t.town_from = 'Moscow'
),
dsComeM AS
(SELECT p.ID_psg, COUNT(*) count
 FROM Pass_in_trip p, Trip t
 WHERE t.trip_no = p.trip_no and
      t.town_to = 'Moscow'
 GROUP BY p.ID_psg
 HAVING COUNT(*) > 1
)
SELECT p.name, dsComeM.count
FROM dsComeM, Passenger p
WHERE p.ID_psg = dsComeM.ID_psg and
      dsComeM.ID_psg not in (SELECT dsFirstM.ID_psg
                             FROM dsFirstM 
                            )
Задание: 94 (Serge I: 2003-04-09)
Для семи последовательных дней, начиная от минимальной даты, когда из Ростова было совершено максимальное число рейсов, определить число рейсов из Ростова. 
Вывод: дата, количество рейсов
WITH dsMax AS 
(SELECT p.date
 FROM Trip t, Pass_in_trip p 
 WHERE t.trip_no = p.trip_no and
       t.town_from = 'Rostov'
 GROUP BY p.date
HAVING count(DISTINCT p.trip_no) = (SELECT TOP 1 count(DISTINCT p.trip_no)
                                      FROM Trip t, Pass_in_trip p 
                                      WHERE t.trip_no = p.trip_no and
                                            t.town_from = 'Rostov'
                                      GROUP BY p.date
                                     ORDER BY count(DISTINCT p.trip_no) DESC
                                     )
),
dsDates AS 
(SELECT DATEADD(day, 0, (SELECT min(date)
                         FROM dsMax)) date1
 UNION
 SELECT DATEADD(day, 1, (SELECT min(date)
                         FROM dsMax)) 
 UNION
 SELECT DATEADD(day, 2, (SELECT min(date)
                         FROM dsMax)) 
 UNION
 SELECT DATEADD(day, 3, (SELECT min(date)
                         FROM dsMax)) 
 UNION
 SELECT DATEADD(day, 4, (SELECT min(date)
                         FROM dsMax))
 UNION
 SELECT DATEADD(day, 5, (SELECT min(date)
                         FROM dsMax))
 UNION
 SELECT DATEADD(day, 6, (SELECT min(date)
                         FROM dsMax))
),
dsRostov AS
(SELECT p.date , count(DISTINCT p.trip_no) count
 FROM Pass_in_trip p,
      Trip t
 WHERE t.trip_no = p.trip_no and
       t.town_from = 'Rostov' 
 group by p.date
)
SELECT  dsDates.date1, COALESCE(dsRostov.count, 0)
FROM dsDates left join dsRostov on dsDates.date1 = dsRostov.date

Задание: 120 (mslava: 2004-01-05)
Для каждой авиакомпании, самолеты которой перевезли хотя бы одного пассажира, вычислить с точностью до двух десятичных знаков средние величины времени нахождения самолетов в воздухе (в минутах). Также рассчитать указанные характеристики по всем летавшим самолетам (использовать слово 'TOTAL').
Вывод: компания, среднее арифметическое, среднее геометрическое, среднее квадратичное, среднее гармоническое.

Для справки:

среднее арифметическое = (x1 + x2 + ... + xN)/N 

среднее геометрическое = (x1 * x2 * ... * xN)^(1/N) 

среднее квадратичное = sqrt((x1^2 + x2^2 + ... + xN^2)/N) 

среднее гармоническое = N/(1/x1 + 1/x2 + ... + 1/xN)
select coalesce(c.name, 'TOTAL'), A_mean, G_mean, Q_mean, H_mean 
from (
	select  ID_Comp,
		convert(numeric(18,2), avg(atime)) A_mean,
		convert(numeric(18,2), Exp(avg(Log(atime)))) G_mean, 
		convert(numeric(18,2), sqrt(avg(atime*atime))) Q_mean,
		convert(numeric(18,2), count(*)/sum(1/atime)) H_mean
	from (
		select ID_Comp,  trip_no, iif(atime < 0 , 1440 + atime, atime) as atime
		from (
			select company.ID_Comp, trip_no, DATEDIFF(minute, time_out, time_in) * 1.00 as atime
			from company inner join trip on company.ID_comp = trip.ID_comp) as t1
		) as t2
	inner join (
		select trip_no 
			from Pass_in_trip 
			group by trip_no, [date]) pt on t2.trip_no = pt.trip_no
			group by ID_Comp with cube
		) as a
	left join Company c on a.ID_comp = c.ID_comp

Задание: 114 (Serge I: 2003-04-08)
Определить имена разных пассажиров, которым чаще других доводилось лететь на одном и том же месте. Вывод: имя и количество полетов на одном и том же месте.
WITH dsPsg AS
(SELECT 
     p.ID_psg, 
     count(*) count,
     max(count(*)) over () max
 FROM 
     Pass_in_trip p, Trip t
 WHERE 
     t.trip_no = p.trip_no 
 GROUP BY 
     p.place,
     p.ID_psg
)
SELECT
    p.name,
    max(dsPsg.count)
FROM 
    dsPsg,
    Passenger p
WHERE 
    p.ID_psg = dsPsg.ID_psg and
    dsPsg.max = dsPsg.count
GROUP BY 
    p.ID_psg,
    p.name

Задание: 141 (Serge I: 2017-11-03)
Для каждого из летавших пассажиров определить количество дней в апреле 2003 года, попавших в интервал между датами первого и последнего вылета пассажира включительно. 
Вывести имя пассажира и количество дней.
WITH 
dsPgs AS
     (SELECT 
          p.ID_psg, 
          IIF(DATEDIFF(DAY, min(date),'2003-04-01') > 0,
              '2003-04-01',
              min(date)
             ) mindate,
          IIF(DATEDIFF(DAY, max(date), '2003-04-30') > 0,
              max(date),
              '2003-04-30'
             )  maxdate
      FROM 
          Pass_in_trip p
      GROUP BY 
          p.ID_psg
      )
SELECT
    p.name,
    IIF(DATEDIFF(DAY, dsPgs.mindate, dsPgs.maxdate) + 1 < 0,
        0,
        DATEDIFF(DAY, dsPgs.mindate, dsPgs.maxdate) + 1
       )
FROM 
    dsPgs,
    Passenger p
WHERE
    p.ID_psg = dsPgs.ID_psg

Задание: 142 (Serge I: 2003-08-28)
Среди пассажиров, летавших на самолетах только одного типа, определить тех, кто прилетал в один и тот же город не менее 2-х раз.
Вывести имена пассажиров.
WITH 
dsPsg AS
    (SELECT 
         p.ID_psg
     FROM 
         Pass_in_trip p
         INNER JOIN Trip t
         ON t.trip_no = p.trip_no 
     GROUP BY 
         p.ID_psg
     HAVING 
         MAX(t.plane) = MIN(t.plane) AND
	 COUNT(town_to) >  COUNT(DISTINCT town_to) 
)
SELECT
    p.name
FROM 
    Passenger p
WHERE    
    p.ID_psg IN (SELECT dsPsg.ID_psg FROM dsPsg)
Задание: 133 (yuriy.rozhok: 2007-03-24)
Пусть имеется некоторое подмножество S множества целых чисел. Назовем "горкой с вершиной N" последовательность чисел из S, в которой числа, меньшие N, выстроены (слева направо без разделителей) сначала возрастающей цепочкой, а потом – убывающей цепочкой, и значением N между ними.
Например , для S = {1, 2, …, 10} горка с вершиной 5 представляется такой последовательностью: 123454321. При S, состоящем из идентификаторов всех компаний, для каждой компании построить "горку", рассматривая ее идентификатор в качестве вершины.
Считать идентификаторы положительными числами и учесть, что в базе нет данных, при которых количество цифр в "горке" может превысить 70.
Вывод: id_comp, "горка"
WITH 
dsN AS
   (
    SELECT c.ID_comp N
    FROM Company c      
   ),
dsUp AS 
   (
    SELECT
        ISNULL(STRING_AGG(dsN.n,'') 
               WITHIN GROUP (ORDER BY dsN.n),
               ''
               ) up,
        c.ID_comp id
    FROM
        Company c
        LEFT JOIN dsN
        ON c.ID_comp > dsN.N
    GROUP BY 
        c.ID_comp
    ),
dsDown AS 
   (
    SELECT
        ISNULL(STRING_AGG(dsN.n,'') 
               WITHIN GROUP (ORDER BY dsN.n DESC),
               ''
               ) down, 
        c.ID_comp id
    FROM
        Company c
        LEFT JOIN dsN
        ON c.ID_comp > dsN.N
    GROUP BY 
        c.ID_comp
    )
SELECT
    dsUp.id,
    dsUp.up + 
    CAST(dsUp.id as VARCHAR(MAX)) +
    dsDown.down
FROM 
    dsUp,
    dsDown
WHERE
    dsUp.id = dsDown.id

Задание: 6 (pаparome: 2005-12-02) 
Предполагая, что не существует номера рейса большего 65535,
вывести номер рейса и его представление в двоичной системе счисления (без ведущих нулей)
with dsN as
(
SELECT
   trip_no,
   LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2) as bit)))
+LTRIM(STR(cast(trip_no&1 as bit))) n

FROM
   Trip
)
SELECT
    trip_no,
    SUBSTRING(n, CHARINDEX('1', n),255)
FROM
   dsN


Задание: 8 (Serge I: 2003-04-08) 
Определить имена разных пассажиров, летевших на одном и том же месте хотя бы два раза подряд.

WITH dsPsg AS
(SELECT pt.Id_psg id, pt.place, LAG(pt.place) OVER(partition by pt.id_psg ORDER BY pt.Id_psg, pt.date + t.time_out) lp
FROM Pass_in_trip pt, Trip t
WHERE t.trip_no = pt.trip_no 
)
SELECT
    MAX(p.name)
FROM 
    dsPsg, 
    Passenger p
WHERE 
    p.Id_psg = dsPsg.id and
    dsPsg.place = dsPsg.lp
GROUP BY
    p.Id_psg


Задание: 14 (Serge I: 2003-04-08) 
Определить номера пассажиров, приземлявшихся в городах, из которых они ранее в тот же день вылетали. 
Вывод: ID_psg, дата.
SELECT
   distinct p.ID_psg,
    p.date
FROM
    Trip t,
    Pass_in_trip p
WHERE
    t.trip_no = p.trip_no and
    exists  (SELECT
                     pOut.ID_psg
                 FROM
                     Trip tOut,
                     Pass_in_trip pOut
                 WHERE
                     tOut.trip_no = pOut.trip_no and 
                     pOut.ID_psg = p.ID_psg and
                     tOut.town_from = t.town_to and
                 DATEADD(DAY,IIF(t.time_in<t.time_out,1,0),p.date) = pOut.date
                   and  tOut.time_out < t.time_in
                  )

***/
