/***
Схема БД состоит из четырех отношений:
Company (ID_comp, name)
Trip(trip_no, ID_comp, plane, town_from, town_to, time_out, time_in)
Passenger(ID_psg, name)
Pass_in_trip(trip_no, date, ID_psg, place)
Таблица Company содержит идентификатор и название компании, осуществляющей перевозку пассажиров. Таблица Trip содержит информацию о рейсах: номер рейса, идентификатор компании, тип самолета, город отправления, город прибытия, время отправления и время прибытия. Таблица Passenger содержит идентификатор и имя пассажира. Таблица Pass_in_trip содержит информацию о полетах: номер рейса, дата вылета (день), идентификатор пассажира и место, на котором он сидел во время полета. При этом следует иметь в виду, что
- рейсы выполняются ежедневно, а длительность полета любого рейса менее суток; town_from <> town_to;
- время и дата учитывается относительно одного часового пояса;
- время отправления и прибытия указывается с точностью до минуты;
- среди пассажиров могут быть однофамильцы (одинаковые значения поля name, например, Bruce Willis);
- номер места в салоне – это число с буквой; число определяет номер ряда, буква (a – d) – место в ряду слева направо в алфавитном порядке;
- связи и ограничения показаны на схеме данных.***/

/***
Задание: 76 (Serge I: 2003-08-28)
Определить время, проведенное в полетах, для пассажиров, летавших всегда на разных местах. Вывод: имя пассажира, время в минутах.


WITH dsPsg AS
(SELECT pt.Id_psg id
FROM Pass_in_trip pt, Trip t
WHERE t.trip_no = pt.trip_no 
GROUP BY pt.Id_psg
HAVING COUNT(DISTINCT pt.place) = COUNT(pt.place)
),
dsTime AS
(SELECT pt.Id_psg id, 
        sum(DATEDIFF(minute, time_out, DATEADD(DAY,IIF(time_in<time_out,1,0)
                     ,time_in))
           ) dur 
 FROM Pass_in_trip pt, Trip t
 WHERE t.trip_no = pt.trip_no 
 GROUP BY pt.Id_psg
)
SELECT p.name, dsTime.dur
FROM dsPsg, Passenger p, dsTime
WHERE p.ID_psg = dsPsg.id and
      dsTime.id = p.ID_psg

Задание: 88 (Serge I: 2003-04-29)
Среди тех, кто пользуется услугами только одной компании, определить имена разных пассажиров, летавших чаще других. 
Вывести: имя пассажира, число полетов и название компании.
WITH dsPsg AS
(SELECT p.ID_psg,
        COUNT(DISTINCT t.ID_comp) countComp,
        COUNT(*) trip_Qty,
        max(t.ID_comp) idComp
 FROM Trip t, Pass_in_trip p
 WHERE p.trip_no = t.trip_no
 GROUP BY p.ID_psg
 HAVING COUNT(DISTINCT t.ID_comp) = 1
)
SELECT p.name, dsPsg.trip_Qty, c.name
FROM dsPsg, Company c, Passenger p
WHERE dsPsg.ID_psg = p.ID_psg and
      dsPsg.idComp = c.ID_Comp and
      dsPsg.trip_Qty = (SELECT max(dsPsg.trip_Qty)
                        FROM dsPsg
                       )

Задание: 87 (Serge I: 2003-08-28)
Считая, что пункт самого первого вылета пассажира является местом жительства, найти не москвичей, которые прилетали в Москву более одного раза. 
Вывод: имя пассажира, количество полетов в Москву
WITH dsFirst AS
(SELECT p.ID_psg, min(date + time_out) date
 FROM Pass_in_trip p, Trip t
 WHERE t.trip_no = p.trip_no
 GROUP BY p.ID_psg
),
dsFirstM AS
(SELECT p.ID_psg
FROM dsFirst, Pass_in_trip p, Trip t
WHERE dsFirst.date = (p.date + time_out) and 
      dsFirst.ID_psg = p.ID_psg and 
      t.trip_no = p.trip_no and
      t.town_from = 'Moscow'
),
dsComeM AS
(SELECT p.ID_psg, COUNT(*) count
 FROM Pass_in_trip p, Trip t
 WHERE t.trip_no = p.trip_no and
      t.town_to = 'Moscow'
 GROUP BY p.ID_psg
 HAVING COUNT(*) > 1
)
SELECT p.name, dsComeM.count
FROM dsComeM, Passenger p
WHERE p.ID_psg = dsComeM.ID_psg and
      dsComeM.ID_psg not in (SELECT dsFirstM.ID_psg
                             FROM dsFirstM 
                            )
Задание: 94 (Serge I: 2003-04-09)
Для семи последовательных дней, начиная от минимальной даты, когда из Ростова было совершено максимальное число рейсов, определить число рейсов из Ростова. 
Вывод: дата, количество рейсов
WITH dsMax AS 
(SELECT p.date
 FROM Trip t, Pass_in_trip p 
 WHERE t.trip_no = p.trip_no and
       t.town_from = 'Rostov'
 GROUP BY p.date
HAVING count(DISTINCT p.trip_no) = (SELECT TOP 1 count(DISTINCT p.trip_no)
                                      FROM Trip t, Pass_in_trip p 
                                      WHERE t.trip_no = p.trip_no and
                                            t.town_from = 'Rostov'
                                      GROUP BY p.date
                                     ORDER BY count(DISTINCT p.trip_no) DESC
                                     )
),
dsDates AS 
(SELECT DATEADD(day, 0, (SELECT min(date)
                         FROM dsMax)) date1
 UNION
 SELECT DATEADD(day, 1, (SELECT min(date)
                         FROM dsMax)) 
 UNION
 SELECT DATEADD(day, 2, (SELECT min(date)
                         FROM dsMax)) 
 UNION
 SELECT DATEADD(day, 3, (SELECT min(date)
                         FROM dsMax)) 
 UNION
 SELECT DATEADD(day, 4, (SELECT min(date)
                         FROM dsMax))
 UNION
 SELECT DATEADD(day, 5, (SELECT min(date)
                         FROM dsMax))
 UNION
 SELECT DATEADD(day, 6, (SELECT min(date)
                         FROM dsMax))
),
dsRostov AS
(SELECT p.date , count(DISTINCT p.trip_no) count
 FROM Pass_in_trip p,
      Trip t
 WHERE t.trip_no = p.trip_no and
       t.town_from = 'Rostov' 
 group by p.date
)
SELECT  dsDates.date1, COALESCE(dsRostov.count, 0)
FROM dsDates left join dsRostov on dsDates.date1 = dsRostov.date

Задание: 120 (mslava: 2004-01-05)
Для каждой авиакомпании, самолеты которой перевезли хотя бы одного пассажира, вычислить с точностью до двух десятичных знаков средние величины времени нахождения самолетов в воздухе (в минутах). Также рассчитать указанные характеристики по всем летавшим самолетам (использовать слово 'TOTAL').
Вывод: компания, среднее арифметическое, среднее геометрическое, среднее квадратичное, среднее гармоническое.

Для справки:

среднее арифметическое = (x1 + x2 + ... + xN)/N 

среднее геометрическое = (x1 * x2 * ... * xN)^(1/N) 

среднее квадратичное = sqrt((x1^2 + x2^2 + ... + xN^2)/N) 

среднее гармоническое = N/(1/x1 + 1/x2 + ... + 1/xN)
select coalesce(c.name, 'TOTAL'), A_mean, G_mean, Q_mean, H_mean 
from (
	select  ID_Comp,
		convert(numeric(18,2), avg(atime)) A_mean,
		convert(numeric(18,2), Exp(avg(Log(atime)))) G_mean, 
		convert(numeric(18,2), sqrt(avg(atime*atime))) Q_mean,
		convert(numeric(18,2), count(*)/sum(1/atime)) H_mean
	from (
		select ID_Comp,  trip_no, iif(atime < 0 , 1440 + atime, atime) as atime
		from (
			select company.ID_Comp, trip_no, DATEDIFF(minute, time_out, time_in) * 1.00 as atime
			from company inner join trip on company.ID_comp = trip.ID_comp) as t1
		) as t2
	inner join (
		select trip_no 
			from Pass_in_trip 
			group by trip_no, [date]) pt on t2.trip_no = pt.trip_no
			group by ID_Comp with cube
		) as a
	left join Company c on a.ID_comp = c.ID_comp

Задание: 114 (Serge I: 2003-04-08)
Определить имена разных пассажиров, которым чаще других доводилось лететь на одном и том же месте. Вывод: имя и количество полетов на одном и том же месте.
WITH dsPsg AS
(SELECT 
     p.ID_psg, 
     count(*) count,
     max(count(*)) over () max
 FROM 
     Pass_in_trip p, Trip t
 WHERE 
     t.trip_no = p.trip_no 
 GROUP BY 
     p.place,
     p.ID_psg
)
SELECT
    p.name,
    max(dsPsg.count)
FROM 
    dsPsg,
    Passenger p
WHERE 
    p.ID_psg = dsPsg.ID_psg and
    dsPsg.max = dsPsg.count
GROUP BY 
    p.ID_psg,
    p.name

Задание: 141 (Serge I: 2017-11-03)
Для каждого из летавших пассажиров определить количество дней в апреле 2003 года, попавших в интервал между датами первого и последнего вылета пассажира включительно. 
Вывести имя пассажира и количество дней.
WITH 
dsPgs AS
     (SELECT 
          p.ID_psg, 
          IIF(DATEDIFF(DAY, min(date),'2003-04-01') > 0,
              '2003-04-01',
              min(date)
             ) mindate,
          IIF(DATEDIFF(DAY, max(date), '2003-04-30') > 0,
              max(date),
              '2003-04-30'
             )  maxdate
      FROM 
          Pass_in_trip p
      GROUP BY 
          p.ID_psg
      )
SELECT
    p.name,
    IIF(DATEDIFF(DAY, dsPgs.mindate, dsPgs.maxdate) + 1 < 0,
        0,
        DATEDIFF(DAY, dsPgs.mindate, dsPgs.maxdate) + 1
       )
FROM 
    dsPgs,
    Passenger p
WHERE
    p.ID_psg = dsPgs.ID_psg

Задание: 142 (Serge I: 2003-08-28)
Среди пассажиров, летавших на самолетах только одного типа, определить тех, кто прилетал в один и тот же город не менее 2-х раз.
Вывести имена пассажиров.
WITH 
dsPsg AS
    (SELECT 
         p.ID_psg
     FROM 
         Pass_in_trip p
         INNER JOIN Trip t
         ON t.trip_no = p.trip_no 
     GROUP BY 
         p.ID_psg
     HAVING 
         MAX(t.plane) = MIN(t.plane) AND
	 COUNT(town_to) >  COUNT(DISTINCT town_to) 
)
SELECT
    p.name
FROM 
    Passenger p
WHERE    
    p.ID_psg IN (SELECT dsPsg.ID_psg FROM dsPsg)
Задание: 133 (yuriy.rozhok: 2007-03-24)
Пусть имеется некоторое подмножество S множества целых чисел. Назовем "горкой с вершиной N" последовательность чисел из S, в которой числа, меньшие N, выстроены (слева направо без разделителей) сначала возрастающей цепочкой, а потом – убывающей цепочкой, и значением N между ними.
Например , для S = {1, 2, …, 10} горка с вершиной 5 представляется такой последовательностью: 123454321. При S, состоящем из идентификаторов всех компаний, для каждой компании построить "горку", рассматривая ее идентификатор в качестве вершины.
Считать идентификаторы положительными числами и учесть, что в базе нет данных, при которых количество цифр в "горке" может превысить 70.
Вывод: id_comp, "горка"
WITH 
dsN AS
   (
    SELECT c.ID_comp N
    FROM Company c      
   ),
dsUp AS 
   (
    SELECT
        ISNULL(STRING_AGG(dsN.n,'') 
               WITHIN GROUP (ORDER BY dsN.n),
               ''
               ) up,
        c.ID_comp id
    FROM
        Company c
        LEFT JOIN dsN
        ON c.ID_comp > dsN.N
    GROUP BY 
        c.ID_comp
    ),
dsDown AS 
   (
    SELECT
        ISNULL(STRING_AGG(dsN.n,'') 
               WITHIN GROUP (ORDER BY dsN.n DESC),
               ''
               ) down, 
        c.ID_comp id
    FROM
        Company c
        LEFT JOIN dsN
        ON c.ID_comp > dsN.N
    GROUP BY 
        c.ID_comp
    )
SELECT
    dsUp.id,
    dsUp.up + 
    CAST(dsUp.id as VARCHAR(MAX)) +
    dsDown.down
FROM 
    dsUp,
    dsDown
WHERE
    dsUp.id = dsDown.id

Задание: 6 (pаparome: 2005-12-02) 
Предполагая, что не существует номера рейса большего 65535,
вывести номер рейса и его представление в двоичной системе счисления (без ведущих нулей)
with dsN as
(
SELECT
   trip_no,
   LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2) as bit)))
+LTRIM(STR(cast(trip_no&1 as bit))) n

FROM
   Trip
)
SELECT
    trip_no,
    SUBSTRING(n, CHARINDEX('1', n),255)
FROM
   dsN


Задание: 8 (Serge I: 2003-04-08) 
Определить имена разных пассажиров, летевших на одном и том же месте хотя бы два раза подряд.

WITH dsPsg AS
(SELECT pt.Id_psg id, pt.place, LAG(pt.place) OVER(partition by pt.id_psg ORDER BY pt.Id_psg, pt.date + t.time_out) lp
FROM Pass_in_trip pt, Trip t
WHERE t.trip_no = pt.trip_no 
)
SELECT
    MAX(p.name)
FROM 
    dsPsg, 
    Passenger p
WHERE 
    p.Id_psg = dsPsg.id and
    dsPsg.place = dsPsg.lp
GROUP BY
    p.Id_psg


Задание: 14 (Serge I: 2003-04-08) 
Определить номера пассажиров, приземлявшихся в городах, из которых они ранее в тот же день вылетали. 
Вывод: ID_psg, дата.
SELECT
   distinct p.ID_psg,
    p.date
FROM
    Trip t,
    Pass_in_trip p
WHERE
    t.trip_no = p.trip_no and
    exists  (SELECT
                     pOut.ID_psg
                 FROM
                     Trip tOut,
                     Pass_in_trip pOut
                 WHERE
                     tOut.trip_no = pOut.trip_no and 
                     pOut.ID_psg = p.ID_psg and
                     tOut.town_from = t.town_to and
                 DATEADD(DAY,IIF(t.time_in<t.time_out,1,0),p.date) = pOut.date
                   and  tOut.time_out < t.time_in
                  )

Задание: 15 (Дмитрий Гринкевич: 2012-04-20) 
Для каждого пассажира, который летал на самолётах разных авиакомпаний, найти количество полетов на самолетах каждой из этих авиакомпаний, а также общее количество полётов пассажира.
Вывод: имя пассажира, количество полётов, название компании или "FLIGHTS_TOTAL" для общего количества.

WITH dsPsg AS
(SELECT p.ID_psg,
        COUNT(*) trip_Qty,
        t.ID_comp idComp
 FROM Trip t, Pass_in_trip p
 WHERE p.trip_no = t.trip_no
 GROUP BY p.ID_psg, t.ID_comp
)
SELECT
   (SELECT name FROM Passenger WHERE ID_psg = dsPsg.ID_psg),
   SUM(trip_Qty),
   COALESCE((SELECT name FROM Company WHERE ID_comp = dsPsg.idComp),'FLIGHTS_TOTAL')
FROM 
   dsPsg
WHERE
   ID_psg in (SELECT
                  ID_psg
              FROM 
                  dsPsg
              GROUP BY 
                  ID_psg
              HAVING COUNT(DISTINCT idComp) > 1
              )
GROUP BY GROUPING SETS((ID_psg, idComp),(ID_psg))

Задание: 17 (VIG: 2003-04-29) 
Определить названия тех авиакомпаний, множество типов самолетов каждой из которых содержит все непустое множество типов самолетов хотя бы одной другой компании.

SELECT DISTINCT
   (SELECT name FROM Company WHERE ID_comp=t.ID_comp)
FROM
   Trip t,
   Trip t1
WHERE
   t.ID_comp <> t1.ID_comp AND
   t.plane = t1.plane
GROUP BY 
   t.ID_comp, t1.ID_comp
HAVING 
   COUNT(DISTINCT t.plane) = 
   (SELECT COUNT(DISTINCT tIn.plane) FROM Trip tIn WHERE tIn.ID_comp=t1.ID_comp)

Задание: 19 (Serge I: 2004-06-23) 

Определить сколько раз каждая буква (латинская без учета регистра) встречалась на всех проданных билетах.

На билете имеется следующая информация: название компании и самолета, названия городов отправления и назначения, номер места и имя пассажира.

Вывод: буква, количество повторений этой буквы
WITH 
dsS AS
(
SELECT
   c.name + 
   CAST(t.plane AS VARCHAR) +
   CAST(t.town_from AS VARCHAR) +
   CAST(t.town_to AS VARCHAR) +
   CAST(pt.place AS VARCHAR) +   
   CAST(p.name AS VARCHAR) s
FROM
   Pass_in_trip pt
   INNER JOIN Trip t ON t.trip_no = pt.trip_no
   INNER JOIN Passenger p ON p.ID_psg = pt.ID_psg
   INNER JOIN Company c ON c.ID_comp = t.ID_comp
)
SELECT 
    value,
    SUM(DATALENGTH(s) -DATALENGTH(replace(s,value,'')))
FROM 
    dsS,  
    (VALUES('a'),('b'),('c'),('d'),('e'),('f'),('g'),('h'),('i'),('j'),('k'),('l'),('m'),('n'),('o'),('p'),('q'),('r'),('s'),('t'),('u'),('v'),('w'),('x'),('y'),('z')) X(value)
group by value

Задание: 20 (VIG: 2003-09-01) 
Определить интервалы полных дней в течение с 28/03/2003 по 28/04/2003 включительно, когда аэропорт Ростова был закрыт (из-за нелетной погоды), т.е. не принял и не выпустил ни одного рейса. 
Вывод: начальная и конечная даты интервала дней, когда не было рейсов.
Примечание: даты выводить в формате "YYYY-MM-DD".
SELECT
   FORMAT(DATEADD(day,1,date), 'yyyy-MM-dd'),
   FORMAT(DATEADD(day,-1,next), 'yyyy-MM-dd')
FROM (
SELECT
   date,
   COALESCE(LEAD(date) OVER (ORDER BY date), date) next,
   DATEDIFF(day,
            date,
            COALESCE(LEAD(date) OVER (ORDER BY date), date)
           ) diff
FROM 
   (SELECT
   DATEADD(DAY,IIF(t.time_in<t.time_out,1,0),pt.date) date
FROM 
   Trip t
   INNER JOIN Pass_in_trip pt ON t.trip_no = pt.trip_no
WHERE
   (t.town_to = 'Rostov') and
   DATEADD(DAY,IIF(t.time_in<t.time_out,1,0),pt.date) >= '2003.03.28' and
   DATEADD(DAY,IIF(t.time_in<t.time_out,1,0),pt.date) <= '2003.04.28'
UNION
SELECT
   pt.date
FROM 
   Trip t
   INNER JOIN Pass_in_trip pt ON t.trip_no = pt.trip_no
WHERE
   (t.town_from = 'Rostov') and
   pt.date >= '2003.03.28' and
   pt.date <= '2003.04.28'
UNION
 SELECT
 '2003.03.27' 
UNION
 SELECT
 '2003.04.29') dsD
) dsD1 
WHERE 
    diff>1

Задание: 25 (DimaN: 2004-06-22) 
Из пассажиров, которые не вылетали в субботу и воскресенье или же вылетали реже, чем за все остальные дни, найти тех, кто чаще остальных (из их числа) прилетал в понедельник. 
Вывести имена пассажиров.
WITH 
dsP AS
(
SELECT DISTINCT
   pt.id_psg id,
   (SELECT count(id_psg)
    FROM Pass_in_trip
    WHERE DATEPART(weekday, date) in (1, 7) and id_psg = pt.id_psg
   ) c,
   (SELECT count(id_psg)
    FROM Pass_in_trip
    WHERE DATEPART(weekday, date) not in (1, 7) and id_psg = pt.id_psg
   ) c1   
FROM
   Trip t
   INNER JOIN Pass_in_trip pt ON t.trip_no = pt.trip_no
GROUP BY 
   pt.id_psg 

)
SELECT
 TOP 1 WITH TIES (select name from Passenger p where p.id_psg = id) 
FROM 
   dsP
   INNER JOIN Pass_in_trip pt ON dsP.id = pt.id_psg
   INNER JOIN Trip t ON t.trip_no = pt.trip_no
WHERE 
   DATEPART(weekday, DATEADD(DAY,IIF(t.time_in<t.time_out,1,0),pt.date)) = 2
   and (dsP.c = 0 or dsP.c < dsP.c1)
GROUP BY 
   id
ORDER BY 
   COUNT(*) desc


Задание: 29 (GiBis: 2011-09-16) 
Создать выписку по прилетевшим и вылетевшим из Москвы рейсам. Слева от времени вылета/посадки в Москве - информация о прилетавших рейсах, справа - о вылетавших.
Если вылеты и посадки выполнялись в одно время, то они объединяются в строки в порядке возрастания номеров рейсов, т.е. первой парой будут вылет и посадка с наименьшими номерами рейсов и т.д.
Каждый рейс попадает в итоговую выборку один раз, при отсутствии пары строка дополняется null-значениями.
Вывод: авиакомпания, город отправления, номер рейса, дата и время (вылета/посадки в Москве) в формате "YYYY-MM-DD hh:mm", номер рейса, город назначения, авиакомпания.
with
dsAll as
(
SELECT
   MAX(t.ID_comp) idCompFrom,
   MAX(t.town_from) tfrom,
   t.trip_no tripFrom,
   DATEADD(DAY,IIF(t.time_in<t.time_out,1,0),pt.date) + t.time_in date,
   NULL idCompIn,
   NULL tIn,
   NULL tripIn,
   ROW_NUMBER() OVER(PARTITION BY 
                     DATEADD(DAY,IIF(t.time_in<t.time_out,1,0),pt.date) + 
                     t.time_in 
                     ORDER BY t.trip_no) num 
FROM
   Trip t
   INNER JOIN Pass_in_trip pt ON pt.trip_no = t.trip_no
WHERE
   t.town_to = 'Moscow'
GROUP BY 
   t.trip_no,
   DATEADD(DAY,IIF(t.time_in<t.time_out,1,0),pt.date) + t.time_in
UNION ALL
SELECT
   NULL idCompFrom,
   NULL tfrom,
   NULL tripFrom,
   pt.date + t.time_out date,
   MAX(t.ID_comp) idCompIn,
   MAX(t.town_to) tIn,
   t.trip_no tripIn,
   ROW_NUMBER() OVER(PARTITION BY 
                     pt.date +t.time_out
                     ORDER BY t.trip_no
                     ) num 
FROM
   Trip t
   INNER JOIN Pass_in_trip pt ON pt.trip_no = t.trip_no
WHERE
   t.town_from = 'Moscow'
GROUP BY 
   t.trip_no,
   pt.date + t.time_out
)
SELECT
   (select name from Company where id_comp = max(idCompFrom)),
   max(tfrom),
   max(tripFrom),
   format(date,'yyyy-MM-dd HH:mm'),
   max(tripIn),
   max(tIn),
   (select name from Company where id_comp = max(idCompIn))
FROM 
   dsAll
group by 
   date, 
   num

Задание: 30 (Serge I: 2003-08-28) 
Найти пары пассажиров, которые хотя бы дважды летели вместе на соседних местах в одном ряду кресел. 
Вывести имена таких пассажиров в порядке возрастания их номеров (id_psg).SELECT 
   (SELECT name FROM Passenger WHERE id_psg = pt.id_psg),
   (SELECT name FROM Passenger WHERE id_psg = pt1.id_psg)
FROM
   Pass_in_trip pt,
   Pass_in_trip pt1
WHERE
   pt.trip_no = pt1.trip_no and
   pt.date  = pt1.date  and
   SUBSTRING(pt.place, 0, len(pt.place) ) =
   SUBSTRING(pt1.place, 0, len(pt1.place) ) and
   ABS(ASCII(SUBSTRING(pt.place, len(pt.place) , 100)) -
       ASCII(SUBSTRING(pt1.place, len(pt1.place) , 100))) = 1 and
   pt.id_psg <
   pt1.id_psg
GROUP BY 
   pt.id_psg,
   pt1.id_psg
HAVING 
   COUNT(*) >= 2

***/
