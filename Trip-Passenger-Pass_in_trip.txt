/***
Схема БД состоит из четырех отношений:
Company (ID_comp, name)
Trip(trip_no, ID_comp, plane, town_from, town_to, time_out, time_in)
Passenger(ID_psg, name)
Pass_in_trip(trip_no, date, ID_psg, place)
Таблица Company содержит идентификатор и название компании, осуществляющей перевозку пассажиров. Таблица Trip содержит информацию о рейсах: номер рейса, идентификатор компании, тип самолета, город отправления, город прибытия, время отправления и время прибытия. Таблица Passenger содержит идентификатор и имя пассажира. Таблица Pass_in_trip содержит информацию о полетах: номер рейса, дата вылета (день), идентификатор пассажира и место, на котором он сидел во время полета. При этом следует иметь в виду, что
- рейсы выполняются ежедневно, а длительность полета любого рейса менее суток; town_from <> town_to;
- время и дата учитывается относительно одного часового пояса;
- время отправления и прибытия указывается с точностью до минуты;
- среди пассажиров могут быть однофамильцы (одинаковые значения поля name, например, Bruce Willis);
- номер места в салоне – это число с буквой; число определяет номер ряда, буква (a – d) – место в ряду слева направо в алфавитном порядке;
- связи и ограничения показаны на схеме данных.***/

/***
Задание: 76 (Serge I: 2003-08-28)
Определить время, проведенное в полетах, для пассажиров, летавших всегда на разных местах. Вывод: имя пассажира, время в минутах.


WITH dsPsg AS
(SELECT pt.Id_psg id
FROM Pass_in_trip pt, Trip t
WHERE t.trip_no = pt.trip_no 
GROUP BY pt.Id_psg
HAVING COUNT(DISTINCT pt.place) = COUNT(pt.place)
),
dsTime AS
(SELECT pt.Id_psg id, 
        sum(DATEDIFF(minute, time_out, DATEADD(DAY,IIF(time_in<time_out,1,0)
                     ,time_in))
           ) dur 
 FROM Pass_in_trip pt, Trip t
 WHERE t.trip_no = pt.trip_no 
 GROUP BY pt.Id_psg
)
SELECT p.name, dsTime.dur
FROM dsPsg, Passenger p, dsTime
WHERE p.ID_psg = dsPsg.id and
      dsTime.id = p.ID_psg

Задание: 88 (Serge I: 2003-04-29)
Среди тех, кто пользуется услугами только одной компании, определить имена разных пассажиров, летавших чаще других. 
Вывести: имя пассажира, число полетов и название компании.
WITH dsPsg AS
(SELECT p.ID_psg,
        COUNT(DISTINCT t.ID_comp) countComp,
        COUNT(*) trip_Qty,
        max(t.ID_comp) idComp
 FROM Trip t, Pass_in_trip p
 WHERE p.trip_no = t.trip_no
 GROUP BY p.ID_psg
 HAVING COUNT(DISTINCT t.ID_comp) = 1
)
SELECT p.name, dsPsg.trip_Qty, c.name
FROM dsPsg, Company c, Passenger p
WHERE dsPsg.ID_psg = p.ID_psg and
      dsPsg.idComp = c.ID_Comp and
      dsPsg.trip_Qty = (SELECT max(dsPsg.trip_Qty)
                        FROM dsPsg
                       )

Задание: 87 (Serge I: 2003-08-28)
Считая, что пункт самого первого вылета пассажира является местом жительства, найти не москвичей, которые прилетали в Москву более одного раза. 
Вывод: имя пассажира, количество полетов в Москву
WITH dsFirst AS
(SELECT p.ID_psg, min(date + time_out) date
 FROM Pass_in_trip p, Trip t
 WHERE t.trip_no = p.trip_no
 GROUP BY p.ID_psg
),
dsFirstM AS
(SELECT p.ID_psg
FROM dsFirst, Pass_in_trip p, Trip t
WHERE dsFirst.date = (p.date + time_out) and 
      dsFirst.ID_psg = p.ID_psg and 
      t.trip_no = p.trip_no and
      t.town_from = 'Moscow'
),
dsComeM AS
(SELECT p.ID_psg, COUNT(*) count
 FROM Pass_in_trip p, Trip t
 WHERE t.trip_no = p.trip_no and
      t.town_to = 'Moscow'
 GROUP BY p.ID_psg
 HAVING COUNT(*) > 1
)
SELECT p.name, dsComeM.count
FROM dsComeM, Passenger p
WHERE p.ID_psg = dsComeM.ID_psg and
      dsComeM.ID_psg not in (SELECT dsFirstM.ID_psg
                             FROM dsFirstM 
                            )
Задание: 94 (Serge I: 2003-04-09)
Для семи последовательных дней, начиная от минимальной даты, когда из Ростова было совершено максимальное число рейсов, определить число рейсов из Ростова. 
Вывод: дата, количество рейсов
WITH dsMax AS 
(SELECT p.date
 FROM Trip t, Pass_in_trip p 
 WHERE t.trip_no = p.trip_no and
       t.town_from = 'Rostov'
 GROUP BY p.date
HAVING count(DISTINCT p.trip_no) = (SELECT TOP 1 count(DISTINCT p.trip_no)
                                      FROM Trip t, Pass_in_trip p 
                                      WHERE t.trip_no = p.trip_no and
                                            t.town_from = 'Rostov'
                                      GROUP BY p.date
                                     ORDER BY count(DISTINCT p.trip_no) DESC
                                     )
),
dsDates AS 
(SELECT DATEADD(day, 0, (SELECT min(date)
                         FROM dsMax)) date1
 UNION
 SELECT DATEADD(day, 1, (SELECT min(date)
                         FROM dsMax)) 
 UNION
 SELECT DATEADD(day, 2, (SELECT min(date)
                         FROM dsMax)) 
 UNION
 SELECT DATEADD(day, 3, (SELECT min(date)
                         FROM dsMax)) 
 UNION
 SELECT DATEADD(day, 4, (SELECT min(date)
                         FROM dsMax))
 UNION
 SELECT DATEADD(day, 5, (SELECT min(date)
                         FROM dsMax))
 UNION
 SELECT DATEADD(day, 6, (SELECT min(date)
                         FROM dsMax))
),
dsRostov AS
(SELECT p.date , count(DISTINCT p.trip_no) count
 FROM Pass_in_trip p,
      Trip t
 WHERE t.trip_no = p.trip_no and
       t.town_from = 'Rostov' 
 group by p.date
)
SELECT  dsDates.date1, COALESCE(dsRostov.count, 0)
FROM dsDates left join dsRostov on dsDates.date1 = dsRostov.date

Задание: 120 (mslava: 2004-01-05)
Для каждой авиакомпании, самолеты которой перевезли хотя бы одного пассажира, вычислить с точностью до двух десятичных знаков средние величины времени нахождения самолетов в воздухе (в минутах). Также рассчитать указанные характеристики по всем летавшим самолетам (использовать слово 'TOTAL').
Вывод: компания, среднее арифметическое, среднее геометрическое, среднее квадратичное, среднее гармоническое.

Для справки:

среднее арифметическое = (x1 + x2 + ... + xN)/N 

среднее геометрическое = (x1 * x2 * ... * xN)^(1/N) 

среднее квадратичное = sqrt((x1^2 + x2^2 + ... + xN^2)/N) 

среднее гармоническое = N/(1/x1 + 1/x2 + ... + 1/xN)
select coalesce(c.name, 'TOTAL'), A_mean, G_mean, Q_mean, H_mean 
from (
	select  ID_Comp,
		convert(numeric(18,2), avg(atime)) A_mean,
		convert(numeric(18,2), Exp(avg(Log(atime)))) G_mean, 
		convert(numeric(18,2), sqrt(avg(atime*atime))) Q_mean,
		convert(numeric(18,2), count(*)/sum(1/atime)) H_mean
	from (
		select ID_Comp,  trip_no, iif(atime < 0 , 1440 + atime, atime) as atime
		from (
			select company.ID_Comp, trip_no, DATEDIFF(minute, time_out, time_in) * 1.00 as atime
			from company inner join trip on company.ID_comp = trip.ID_comp) as t1
		) as t2
	inner join (
		select trip_no 
			from Pass_in_trip 
			group by trip_no, [date]) pt on t2.trip_no = pt.trip_no
			group by ID_Comp with cube
		) as a
	left join Company c on a.ID_comp = c.ID_comp

Задание: 114 (Serge I: 2003-04-08)
Определить имена разных пассажиров, которым чаще других доводилось лететь на одном и том же месте. Вывод: имя и количество полетов на одном и том же месте.
WITH dsPsg AS
(SELECT 
     p.ID_psg, 
     count(*) count,
     max(count(*)) over () max
 FROM 
     Pass_in_trip p, Trip t
 WHERE 
     t.trip_no = p.trip_no 
 GROUP BY 
     p.place,
     p.ID_psg
)
SELECT
    p.name,
    max(dsPsg.count)
FROM 
    dsPsg,
    Passenger p
WHERE 
    p.ID_psg = dsPsg.ID_psg and
    dsPsg.max = dsPsg.count
GROUP BY 
    p.ID_psg,
    p.name

Задание: 141 (Serge I: 2017-11-03)
Для каждого из летавших пассажиров определить количество дней в апреле 2003 года, попавших в интервал между датами первого и последнего вылета пассажира включительно. 
Вывести имя пассажира и количество дней.
WITH 
dsPgs AS
     (SELECT 
          p.ID_psg, 
          IIF(DATEDIFF(DAY, min(date),'2003-04-01') > 0,
              '2003-04-01',
              min(date)
             ) mindate,
          IIF(DATEDIFF(DAY, max(date), '2003-04-30') > 0,
              max(date),
              '2003-04-30'
             )  maxdate
      FROM 
          Pass_in_trip p
      GROUP BY 
          p.ID_psg
      )
SELECT
    p.name,
    IIF(DATEDIFF(DAY, dsPgs.mindate, dsPgs.maxdate) + 1 < 0,
        0,
        DATEDIFF(DAY, dsPgs.mindate, dsPgs.maxdate) + 1
       )
FROM 
    dsPgs,
    Passenger p
WHERE
    p.ID_psg = dsPgs.ID_psg

Задание: 142 (Serge I: 2003-08-28)
Среди пассажиров, летавших на самолетах только одного типа, определить тех, кто прилетал в один и тот же город не менее 2-х раз.
Вывести имена пассажиров.
WITH 
dsPsg AS
    (SELECT 
         p.ID_psg
     FROM 
         Pass_in_trip p
         INNER JOIN Trip t
         ON t.trip_no = p.trip_no 
     GROUP BY 
         p.ID_psg
     HAVING 
         MAX(t.plane) = MIN(t.plane) AND
	 COUNT(town_to) >  COUNT(DISTINCT town_to) 
)
SELECT
    p.name
FROM 
    Passenger p
WHERE    
    p.ID_psg IN (SELECT dsPsg.ID_psg FROM dsPsg)
Задание: 133 (yuriy.rozhok: 2007-03-24)
Пусть имеется некоторое подмножество S множества целых чисел. Назовем "горкой с вершиной N" последовательность чисел из S, в которой числа, меньшие N, выстроены (слева направо без разделителей) сначала возрастающей цепочкой, а потом – убывающей цепочкой, и значением N между ними.
Например , для S = {1, 2, …, 10} горка с вершиной 5 представляется такой последовательностью: 123454321. При S, состоящем из идентификаторов всех компаний, для каждой компании построить "горку", рассматривая ее идентификатор в качестве вершины.
Считать идентификаторы положительными числами и учесть, что в базе нет данных, при которых количество цифр в "горке" может превысить 70.
Вывод: id_comp, "горка"
WITH 
dsN AS
   (
    SELECT c.ID_comp N
    FROM Company c      
   ),
dsUp AS 
   (
    SELECT
        ISNULL(STRING_AGG(dsN.n,'') 
               WITHIN GROUP (ORDER BY dsN.n),
               ''
               ) up,
        c.ID_comp id
    FROM
        Company c
        LEFT JOIN dsN
        ON c.ID_comp > dsN.N
    GROUP BY 
        c.ID_comp
    ),
dsDown AS 
   (
    SELECT
        ISNULL(STRING_AGG(dsN.n,'') 
               WITHIN GROUP (ORDER BY dsN.n DESC),
               ''
               ) down, 
        c.ID_comp id
    FROM
        Company c
        LEFT JOIN dsN
        ON c.ID_comp > dsN.N
    GROUP BY 
        c.ID_comp
    )
SELECT
    dsUp.id,
    dsUp.up + 
    CAST(dsUp.id as VARCHAR(MAX)) +
    dsDown.down
FROM 
    dsUp,
    dsDown
WHERE
    dsUp.id = dsDown.id

Задание: 6 (pаparome: 2005-12-02) 
Предполагая, что не существует номера рейса большего 65535,
вывести номер рейса и его представление в двоичной системе счисления (без ведущих нулей)
with dsN as
(
SELECT
   trip_no,
   LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2*2) as bit)))
+LTRIM(STR(cast(trip_no&(2) as bit)))
+LTRIM(STR(cast(trip_no&1 as bit))) n

FROM
   Trip
)
SELECT
    trip_no,
    SUBSTRING(n, CHARINDEX('1', n),255)
FROM
   dsN


Задание: 8 (Serge I: 2003-04-08) 
Определить имена разных пассажиров, летевших на одном и том же месте хотя бы два раза подряд.

WITH dsPsg AS
(SELECT pt.Id_psg id, pt.place, LAG(pt.place) OVER(partition by pt.id_psg ORDER BY pt.Id_psg, pt.date + t.time_out) lp
FROM Pass_in_trip pt, Trip t
WHERE t.trip_no = pt.trip_no 
)
SELECT
    MAX(p.name)
FROM 
    dsPsg, 
    Passenger p
WHERE 
    p.Id_psg = dsPsg.id and
    dsPsg.place = dsPsg.lp
GROUP BY
    p.Id_psg


Задание: 14 (Serge I: 2003-04-08) 
Определить номера пассажиров, приземлявшихся в городах, из которых они ранее в тот же день вылетали. 
Вывод: ID_psg, дата.
SELECT
   distinct p.ID_psg,
    p.date
FROM
    Trip t,
    Pass_in_trip p
WHERE
    t.trip_no = p.trip_no and
    exists  (SELECT
                     pOut.ID_psg
                 FROM
                     Trip tOut,
                     Pass_in_trip pOut
                 WHERE
                     tOut.trip_no = pOut.trip_no and 
                     pOut.ID_psg = p.ID_psg and
                     tOut.town_from = t.town_to and
                 DATEADD(DAY,IIF(t.time_in<t.time_out,1,0),p.date) = pOut.date
                   and  tOut.time_out < t.time_in
                  )

Задание: 15 (Дмитрий Гринкевич: 2012-04-20) 
Для каждого пассажира, который летал на самолётах разных авиакомпаний, найти количество полетов на самолетах каждой из этих авиакомпаний, а также общее количество полётов пассажира.
Вывод: имя пассажира, количество полётов, название компании или "FLIGHTS_TOTAL" для общего количества.

WITH dsPsg AS
(SELECT p.ID_psg,
        COUNT(*) trip_Qty,
        t.ID_comp idComp
 FROM Trip t, Pass_in_trip p
 WHERE p.trip_no = t.trip_no
 GROUP BY p.ID_psg, t.ID_comp
)
SELECT
   (SELECT name FROM Passenger WHERE ID_psg = dsPsg.ID_psg),
   SUM(trip_Qty),
   COALESCE((SELECT name FROM Company WHERE ID_comp = dsPsg.idComp),'FLIGHTS_TOTAL')
FROM 
   dsPsg
WHERE
   ID_psg in (SELECT
                  ID_psg
              FROM 
                  dsPsg
              GROUP BY 
                  ID_psg
              HAVING COUNT(DISTINCT idComp) > 1
              )
GROUP BY GROUPING SETS((ID_psg, idComp),(ID_psg))

Задание: 17 (VIG: 2003-04-29) 
Определить названия тех авиакомпаний, множество типов самолетов каждой из которых содержит все непустое множество типов самолетов хотя бы одной другой компании.

SELECT DISTINCT
   (SELECT name FROM Company WHERE ID_comp=t.ID_comp)
FROM
   Trip t,
   Trip t1
WHERE
   t.ID_comp <> t1.ID_comp AND
   t.plane = t1.plane
GROUP BY 
   t.ID_comp, t1.ID_comp
HAVING 
   COUNT(DISTINCT t.plane) = 
   (SELECT COUNT(DISTINCT tIn.plane) FROM Trip tIn WHERE tIn.ID_comp=t1.ID_comp)

Задание: 19 (Serge I: 2004-06-23) 

Определить сколько раз каждая буква (латинская без учета регистра) встречалась на всех проданных билетах.

На билете имеется следующая информация: название компании и самолета, названия городов отправления и назначения, номер места и имя пассажира.

Вывод: буква, количество повторений этой буквы
WITH 
dsS AS
(
SELECT
   c.name + 
   CAST(t.plane AS VARCHAR) +
   CAST(t.town_from AS VARCHAR) +
   CAST(t.town_to AS VARCHAR) +
   CAST(pt.place AS VARCHAR) +   
   CAST(p.name AS VARCHAR) s
FROM
   Pass_in_trip pt
   INNER JOIN Trip t ON t.trip_no = pt.trip_no
   INNER JOIN Passenger p ON p.ID_psg = pt.ID_psg
   INNER JOIN Company c ON c.ID_comp = t.ID_comp
)
SELECT 
    value,
    SUM(DATALENGTH(s) -DATALENGTH(replace(s,value,'')))
FROM 
    dsS,  
    (VALUES('a'),('b'),('c'),('d'),('e'),('f'),('g'),('h'),('i'),('j'),('k'),('l'),('m'),('n'),('o'),('p'),('q'),('r'),('s'),('t'),('u'),('v'),('w'),('x'),('y'),('z')) X(value)
group by value

Задание: 20 (VIG: 2003-09-01) 
Определить интервалы полных дней в течение с 28/03/2003 по 28/04/2003 включительно, когда аэропорт Ростова был закрыт (из-за нелетной погоды), т.е. не принял и не выпустил ни одного рейса. 
Вывод: начальная и конечная даты интервала дней, когда не было рейсов.
Примечание: даты выводить в формате "YYYY-MM-DD".
SELECT
   FORMAT(DATEADD(day,1,date), 'yyyy-MM-dd'),
   FORMAT(DATEADD(day,-1,next), 'yyyy-MM-dd')
FROM (
SELECT
   date,
   COALESCE(LEAD(date) OVER (ORDER BY date), date) next,
   DATEDIFF(day,
            date,
            COALESCE(LEAD(date) OVER (ORDER BY date), date)
           ) diff
FROM 
   (SELECT
   DATEADD(DAY,IIF(t.time_in<t.time_out,1,0),pt.date) date
FROM 
   Trip t
   INNER JOIN Pass_in_trip pt ON t.trip_no = pt.trip_no
WHERE
   (t.town_to = 'Rostov') and
   DATEADD(DAY,IIF(t.time_in<t.time_out,1,0),pt.date) >= '2003.03.28' and
   DATEADD(DAY,IIF(t.time_in<t.time_out,1,0),pt.date) <= '2003.04.28'
UNION
SELECT
   pt.date
FROM 
   Trip t
   INNER JOIN Pass_in_trip pt ON t.trip_no = pt.trip_no
WHERE
   (t.town_from = 'Rostov') and
   pt.date >= '2003.03.28' and
   pt.date <= '2003.04.28'
UNION
 SELECT
 '2003.03.27' 
UNION
 SELECT
 '2003.04.29') dsD
) dsD1 
WHERE 
    diff>1

Задание: 25 (DimaN: 2004-06-22) 
Из пассажиров, которые не вылетали в субботу и воскресенье или же вылетали реже, чем за все остальные дни, найти тех, кто чаще остальных (из их числа) прилетал в понедельник. 
Вывести имена пассажиров.
WITH 
dsP AS
(
SELECT DISTINCT
   pt.id_psg id,
   (SELECT count(id_psg)
    FROM Pass_in_trip
    WHERE DATEPART(weekday, date) in (1, 7) and id_psg = pt.id_psg
   ) c,
   (SELECT count(id_psg)
    FROM Pass_in_trip
    WHERE DATEPART(weekday, date) not in (1, 7) and id_psg = pt.id_psg
   ) c1   
FROM
   Trip t
   INNER JOIN Pass_in_trip pt ON t.trip_no = pt.trip_no
GROUP BY 
   pt.id_psg 

)
SELECT
 TOP 1 WITH TIES (select name from Passenger p where p.id_psg = id) 
FROM 
   dsP
   INNER JOIN Pass_in_trip pt ON dsP.id = pt.id_psg
   INNER JOIN Trip t ON t.trip_no = pt.trip_no
WHERE 
   DATEPART(weekday, DATEADD(DAY,IIF(t.time_in<t.time_out,1,0),pt.date)) = 2
   and (dsP.c = 0 or dsP.c < dsP.c1)
GROUP BY 
   id
ORDER BY 
   COUNT(*) desc


Задание: 29 (GiBis: 2011-09-16) 
Создать выписку по прилетевшим и вылетевшим из Москвы рейсам. Слева от времени вылета/посадки в Москве - информация о прилетавших рейсах, справа - о вылетавших.
Если вылеты и посадки выполнялись в одно время, то они объединяются в строки в порядке возрастания номеров рейсов, т.е. первой парой будут вылет и посадка с наименьшими номерами рейсов и т.д.
Каждый рейс попадает в итоговую выборку один раз, при отсутствии пары строка дополняется null-значениями.
Вывод: авиакомпания, город отправления, номер рейса, дата и время (вылета/посадки в Москве) в формате "YYYY-MM-DD hh:mm", номер рейса, город назначения, авиакомпания.
with
dsAll as
(
SELECT
   MAX(t.ID_comp) idCompFrom,
   MAX(t.town_from) tfrom,
   t.trip_no tripFrom,
   DATEADD(DAY,IIF(t.time_in<t.time_out,1,0),pt.date) + t.time_in date,
   NULL idCompIn,
   NULL tIn,
   NULL tripIn,
   ROW_NUMBER() OVER(PARTITION BY 
                     DATEADD(DAY,IIF(t.time_in<t.time_out,1,0),pt.date) + 
                     t.time_in 
                     ORDER BY t.trip_no) num 
FROM
   Trip t
   INNER JOIN Pass_in_trip pt ON pt.trip_no = t.trip_no
WHERE
   t.town_to = 'Moscow'
GROUP BY 
   t.trip_no,
   DATEADD(DAY,IIF(t.time_in<t.time_out,1,0),pt.date) + t.time_in
UNION ALL
SELECT
   NULL idCompFrom,
   NULL tfrom,
   NULL tripFrom,
   pt.date + t.time_out date,
   MAX(t.ID_comp) idCompIn,
   MAX(t.town_to) tIn,
   t.trip_no tripIn,
   ROW_NUMBER() OVER(PARTITION BY 
                     pt.date +t.time_out
                     ORDER BY t.trip_no
                     ) num 
FROM
   Trip t
   INNER JOIN Pass_in_trip pt ON pt.trip_no = t.trip_no
WHERE
   t.town_from = 'Moscow'
GROUP BY 
   t.trip_no,
   pt.date + t.time_out
)
SELECT
   (select name from Company where id_comp = max(idCompFrom)),
   max(tfrom),
   max(tripFrom),
   format(date,'yyyy-MM-dd HH:mm'),
   max(tripIn),
   max(tIn),
   (select name from Company where id_comp = max(idCompIn))
FROM 
   dsAll
group by 
   date, 
   num

Задание: 30 (Serge I: 2003-08-28) 
Найти пары пассажиров, которые хотя бы дважды летели вместе на соседних местах в одном ряду кресел. 
Вывести имена таких пассажиров в порядке возрастания их номеров (id_psg).SELECT 
   (SELECT name FROM Passenger WHERE id_psg = pt.id_psg),
   (SELECT name FROM Passenger WHERE id_psg = pt1.id_psg)
FROM
   Pass_in_trip pt,
   Pass_in_trip pt1
WHERE
   pt.trip_no = pt1.trip_no and
   pt.date  = pt1.date  and
   SUBSTRING(pt.place, 0, len(pt.place) ) =
   SUBSTRING(pt1.place, 0, len(pt1.place) ) and
   ABS(ASCII(SUBSTRING(pt.place, len(pt.place) , 100)) -
       ASCII(SUBSTRING(pt1.place, len(pt1.place) , 100))) = 1 and
   pt.id_psg <
   pt1.id_psg
GROUP BY 
   pt.id_psg,
   pt1.id_psg
HAVING 
   COUNT(*) >= 2

Задание: 34 (qwrqwr: 2010-09-24) 
Для каждого пассажира, совершавшего рейсы, рассмотреть отдельно первую и вторую половину его рейсов (в хронологическом порядке).
При нечётном числе рейсов у пассажира большее число рейсов отнести к первой половине списка.
По каждой группе рейсов пассажира получить следующую информацию:
- при наличии только одного рейса в группе - название авиакомпании и номер этого рейса (через запятую с пробелом);
- при нескольких рейсах в группе - суммарное время этих рейсов в формате "H hrs., N min." (не выводить часы или минуты если они равны 0);
- при отсутствии рейсов в группе - пустую строку.
Вывести: Имя пассажира, информация по первой части его рейсов, информация по второй части его рейсов.
WITH 
dsP AS
(
SELECT
   pt.ID_psg,
   concat(
   (SELECT TOP 1 trim(name) FROM Company WHERE ID_comp = t.ID_comp),', ',pt.trip_no) comp,
   DATEDIFF(minute , 
            pt.date + t.time_out,
            DATEADD(DAY,IIF(t.time_in<t.time_out,1,0),pt.date) + t.time_in
           ) min,
   IIF(ROW_NUMBER() OVER (PARTITION BY pt.ID_psg ORDER BY pt.date + t.time_out) 
        <= CEILING(COUNT(*) OVER (PARTITION BY pt.ID_psg)/2.0),1,2) as gr
FROM
   Pass_in_trip pt
   INNER JOIN Trip t ON t.trip_no = pt.trip_no
),
dsG as
(
SELECT 
   ID_psg,
   iif(gr = 1,
       iif(count(ID_psg) = 1, max(comp),
           iif(SUM(min)>60,concat(floor(SUM(min)/60.0) , ' hrs.'),'')+
          iif(SUM(min) - floor(SUM(min)/60.0)*60 > 0 and SUM(min)>60, ', ','')+
          iif(SUM(min) - floor(SUM(min)/60.0)*60 > 0, 
              concat(SUM(min) - floor(SUM(min)/60.0)*60, ' min.'),
              ''
             )
       ),
       ''
      ) g1,
   iif(gr = 2,
       iif(count(ID_psg) = 1, max(comp), 
          iif(SUM(min)>60,concat(floor(SUM(min)/60.0) , ' hrs.'),'')+
          iif(SUM(min) - floor(SUM(min)/60.0)*60 > 0 and SUM(min)>60, ', ','')+
          iif(SUM(min) - floor(SUM(min)/60.0)*60 > 0, 
              concat(SUM(min) - floor(SUM(min)/60.0)*60, ' min.'),
              ''
             )
          ),
       ''
      ) g2
FROM
   dsP
GROUP BY 
   ID_psg,
   gr
)
SELECT
   (SELECT name FROM Passenger where ID_psg = dsG.ID_psg),
   max(g1),
   max(g2)
FROM 
   dsG 
group by 
   ID_psg

Задание: 39 (Serge I: 2003-08-28) 
Для каждой компании, совершающей самые продолжительные рейсы, определить количество перевезенных ею пассажиров (если таковые были) по маршрутам самых продолжительных рейсов этой компании (туда и/или обратно). 
Вывод:название компании, число пассажиров. 
WITH
dsT AS
(SELECT  TOP 1 WITH TIES 
   t.id_comp,
   t.town_from,
   t.town_to
FROM
   Trip t
ORDER BY
   (DATEDIFF(minute, 
            t.time_out, 
             DATEADD(DAY,IIF(t.time_in<t.time_out,1,0),t.time_in)
           )) DESC
),
dsG as (
SELECT   
    dsT.id_comp,
    t.trip_no,
   (SELECT COUNT(pt.ID_psg) FROM Pass_in_trip pt WHERE trip_no = t.trip_no) s
FROM 
    Trip t
    INNER JOIN dsT  ON 
          ((t.town_to = dsT.town_to and t.town_from = dsT.town_from) or
           (t.town_to = dsT.town_from and t.town_from = dsT.town_to)
          ) and
          t.id_comp = dsT.id_comp    
        
GROUP BY
    dsT.id_comp, 
    t.trip_no
)
SELECT
    (SELECT name FROM Company WHERE id_comp = dsG.id_comp),
    sum(s)
FROM
    dsG
WHERE 
    s > 0
GROUP BY 
    dsG.id_comp

Задание: 41 (qwrqwr: 2010-04-26) 
Вывести по одному разу такие пары городов (town_from, town_to), которые связаны авиарейсами только друг с другом.
При наличии как прямого, так и обратного рейсов выводить в качестве города отправления тот город, который идет раньше при сортировке по возрастанию.
WITH
dsT AS
(
 SELECT
    town_from t1,
    COUNT(DISTINCT town_to) c,
    MAX(town_to) t2
 FROM
    (select town_from, town_to from Trip t union
     select town_to, town_from from Trip t
    ) trip
 GROUP BY 
    town_from
)
SELECT  distinct
   iif(    EXISTS(SELECT town_from 
               FROM Trip
               WHERE town_from = t.t1 and town_to = t.t2) and 
           EXISTS(SELECT town_from 
               FROM Trip
               WHERE town_from = t.t2 and town_to = t.t1),iif(t1>t2,t2,t1),
   iif(    not EXISTS(SELECT town_from 
               FROM Trip
               WHERE town_from = t.t1 and town_to = t.t2) and 
           EXISTS(SELECT town_from 
               FROM Trip
               WHERE town_from = t.t2 and town_to = t.t1),t2,
   t1)),
   iif(    EXISTS(SELECT town_from 
               FROM Trip
               WHERE town_from = t.t1 and town_to = t.t2) and 
           EXISTS(SELECT town_from 
               FROM Trip
               WHERE town_from = t.t2 and town_to = t.t1),iif(t1>t2,t1,t2),
   iif(    not EXISTS(SELECT town_from 
               FROM Trip
               WHERE town_from = t.t1 and town_to = t.t2) and 
           EXISTS(SELECT town_from 
               FROM Trip
               WHERE town_from = t.t2 and town_to = t.t1),t1,
   t2))
FROM
   dsT t
WHERE
   t.c = 1 AND 
   ((SELECT max(t2) 
           FROM dsT 
           WHERE t1 = t.t2
          ) = t.t1 and
    (SELECT max(c) 
           FROM dsT 
           WHERE t1 = t.t2
          ) = 1 or
    NOT EXISTS(SELECT t1 
               FROM dsT 
               WHERE t1 = t.t2)
   )

Задание: 42 (Serge I: 2003-06-05) 
Для пассажиров, проведших больше всего времени в полетах, определить общее время этих полетов, а также название компании, в самолетах которой они летали большую часть этого времени.
Вывод: имя пассажира, общее время его полетов в минутах, название компании.
WITH
dsT AS
(
SELECT
   pt.ID_psg,
   SUM(DATEDIFF(minute, 
                time_out, 
                DATEADD(DAY, IIF(time_out > time_in, 1, 0), time_in)
               )
      ) OVER (PARTITION BY pt.ID_psg) sumP,
   SUM(DATEDIFF(minute, 
                time_out, 
                DATEADD(DAY, IIF(time_out > time_in, 1, 0), time_in)
               )
      ) OVER (PARTITION BY pt.ID_psg, t.ID_comp) sumC,
   t.ID_comp
FROM
   Trip t
   INNER JOIN Pass_in_trip pt ON pt.trip_no = t.trip_no
)
SELECT 
   (SELECT name FROM Passenger WHERE ID_psg = t.ID_psg),
   max(sumP),
   (SELECT name FROM Company WHERE ID_comp = (t.ID_comp))
FROM
   dsT t
WHERE 
   ID_psg in (SELECT TOP 1 WITH TIES
                 ID_psg
              FROM
                 dsT
              ORDER BY 
                 sumP DESC
              ) AND
   ID_comp in (SELECT TOP 1 WITH TIES
                 ID_comp
               FROM
                 dsT
               WHERE
                 t.ID_psg = ID_psg
               ORDER BY 
                 sumC DESC
              )
GROUP BY
   ID_psg, ID_comp

Задание: 49 (anddros: 2009-06-05) 
В рамках акции, посвященной юбилею компании British_aw, директор по работе с клиентами решил вручить памятные подарки пяти пассажирам, налетавшим самолетами компании больше всего времени. Он дал задание IT-отделу подготовить список таких пассажиров в виде следующей таблицы: 
- в первой строке - имена пассажиров (1.name); 
- во второй - время налета в минутах (2.time); 
- в третьей - количество полетов (3.cou); 
- в четвертой - дата первого вылета (4.time_out); 
- в пятой - дата последнего прилета (5.time_in); 
- в первом столбце - название характеристики; 
- во втором-шестом столбцах - характеристики первого-пятого пассажира соответственно. 
Первый-пятый пассажиры определяются: по убыванию времени налета, возрастанию id_psg.
WITH
dsP AS
(
SELECT 
   pt.ID_psg,
   SUM(DATEDIFF(minute, 
                time_out, 
                DATEADD(DAY, IIF(time_out > time_in, 1, 0), time_in)
               )
      ) OVER (PARTITION BY pt.ID_psg) sumP,
   COUNT(pt.ID_psg) OVER (PARTITION BY pt.ID_psg) c,
   MIN(date + time_out) OVER (PARTITION BY pt.ID_psg) min,
   MAX(date +
       DATEADD(DAY, IIF(time_out > time_in, 1, 0), time_in)
      ) OVER (PARTITION BY pt.ID_psg) max
FROM
   Trip t
   INNER JOIN Pass_in_trip pt ON pt.trip_no = t.trip_no
WHERE 
   t.ID_comp = 5
),
dsP1 AS
(
SELECT 
   ROW_NUMBER() OVER (ORDER BY MAX(sumP) DESC, ID_PSG) num, 
   (SELECT name FROM Passenger WHERE id_psg = p.ID_PSG) name, 
   MAX(sumP) sum,
   MAX(c) c,
   MAX(min) min,
   MAX(max) max
FROM 
   dsP p
WHERE p.ID_psg in ( SELECT ID_PSG FROM (
                   SELECT DISTINCT TOP 5 
                      ID_PSG, sumP
                   FROM 
                      dsP
                   ORDER BY 
                     sumP DESC, ID_PSG ) T
                  )
GROUP BY 
  ID_PSG
)
SELECT 
 '1.name', 
 (SELECT name FROM dsP1 WHERE num =1 ), 
 (SELECT name FROM dsP1 WHERE num =2 ), 
 (SELECT name FROM dsP1 WHERE num =3 ), 
 (SELECT name FROM dsP1 WHERE num =4 ), 
 (SELECT name FROM dsP1 WHERE num =5 )
UNION ALL
SELECT 
 '2.time', 
 (SELECT cast(sum as varchar) FROM dsP1 WHERE num =1 ), 
 (SELECT cast(sum as varchar) FROM dsP1 WHERE num =2 ), 
 (SELECT cast(sum as varchar) FROM dsP1 WHERE num =3 ), 
 (SELECT cast(sum as varchar) FROM dsP1 WHERE num =4 ), 
 (SELECT cast(sum as varchar) FROM dsP1 WHERE num =5 )
UNION ALL
SELECT 
 '3.cou', 
 (SELECT cast(c as varchar) FROM dsP1 WHERE num =1 ), 
 (SELECT cast(c as varchar) FROM dsP1 WHERE num =2 ), 
 (SELECT cast(c as varchar) FROM dsP1 WHERE num =3 ), 
 (SELECT cast(c as varchar) FROM dsP1 WHERE num =4 ), 
 (SELECT cast(c as varchar) FROM dsP1 WHERE num =5 )
UNION ALL
SELECT 
 '4.time_out', 
 (SELECT FORMAT(min,'yyyy-MM-dd HH:mm:ss') FROM dsP1 WHERE num =1 ), 
 (SELECT FORMAT(min,'yyyy-MM-dd HH:mm:ss') FROM dsP1 WHERE num =2 ), 
 (SELECT FORMAT(min,'yyyy-MM-dd HH:mm:ss') FROM dsP1 WHERE num =3 ), 
 (SELECT FORMAT(min,'yyyy-MM-dd HH:mm:ss') FROM dsP1 WHERE num =4 ), 
 (SELECT FORMAT(min,'yyyy-MM-dd HH:mm:ss') FROM dsP1 WHERE num =5 )
UNION ALL
SELECT 
 '5.time_in', 
 (SELECT FORMAT(max,'yyyy-MM-dd HH:mm:ss') FROM dsP1 WHERE num =1 ), 
 (SELECT FORMAT(max,'yyyy-MM-dd HH:mm:ss') FROM dsP1 WHERE num =2 ), 
 (SELECT FORMAT(max,'yyyy-MM-dd HH:mm:ss') FROM dsP1 WHERE num =3 ), 
 (SELECT FORMAT(max,'yyyy-MM-dd HH:mm:ss') FROM dsP1 WHERE num =4 ), 
 (SELECT FORMAT(max,'yyyy-MM-dd HH:mm:ss') FROM dsP1 WHERE num =5 )

Задание: 50 (mslava: 2003-12-23) 
При следующих предположениях:

- в любом самолете 4 места в одном ряду;

- билеты имеют сквозную нумерацию на все места, начиная с 1000 в порядке: дата рейса, номер рейса, порядковый номер места в салоне самолёта;

- число мест в салонах самолетов: boeing = 220 , tu-134 = 70, tu-154 = 160, il-86 = 340, другие = 90

восстановить нумерацию проданных билетов.

Вывод: Номер билета, дата, номер рейса, имя пассажира
SELECT  
  dsP.plane+
  999 + (SUBSTRING(pt.place, 0, len(pt.place)) - 1) * 4 + 
  CASE SUBSTRING(pt.place, len(pt.place) , 100)
       WHEN 'a' THEN 1
       WHEN 'b' THEN 2
       WHEN 'c' THEN 3
       WHEN 'd' THEN 4
       ELSE 0
  END -
  CASE t.plane
       WHEN 'Boeing' THEN 220
       WHEN 'tu-134' THEN 70
       WHEN 'tu-154' THEN 160
       WHEN 'il-86' THEN 340
       ELSE 90
  END,
  pt.date, 
  pt.trip_no,
  (SELECT name FROM Passenger WHERE id_psg = pt.id_psg)
FROM
  Trip t
  INNER JOIN Pass_in_trip pt ON t.trip_no = pt.trip_no,
  (SELECT
  pt.date, 
  pt.trip_no,
  sum(CASE MAX(t.plane)
       WHEN 'Boeing' THEN 220
       WHEN 'tu-134' THEN 70
       WHEN 'tu-154' THEN 160
       WHEN 'il-86' THEN 340
       ELSE 90
  END)
  over (order by pt.date,pt.trip_no) plane
FROM
  Trip t
  INNER JOIN Pass_in_trip pt ON t.trip_no = pt.trip_no
GROUP BY 
  pt.date, 
  pt.trip_no) dsP
WHERE
  dsP.date = pt.date and dsP.trip_no = pt.trip_no

Задание: 54 (Ozzy: 2008-09-06) 
Определить, можно ли на циферблатных часах, показывающих время отправления/прибытия рейса, поменять местами часовую и минутную стрелки так, чтобы такое положение стрелок было возможно при естественном ходе часов. Считать, что на циферблат нанесено 60 делений и обе стрелки перемещаются дискретно по этим делениям. 
При этом не нужно учитывать случаи положения стрелок "одна над другой" (например, для показаний 00:00, 08:43 и т.п.). 
Вывод:
- номер рейса, для которого возможно переставить стрелки ("двойник");
- обозначение:
'D' - если есть "двойник" для времени отправления (time_out);
'A' - если есть "двойник" для времени прибытия (time_in);
'DA' - если есть "двойники" как для времени отправления, так и для времени прибытия рейса.

WITH
dsT AS
(
SELECT
   trip_no, time_out,
   IIF( CAST(FORMAT(time_out, 'hh') AS INT)%12 * 5 + 
        FLOOR(CAST(FORMAT(time_out, 'mm') AS INT)/12.0) >=
        CAST(FORMAT(time_out, 'mm') AS INT) % 5 * 12 AND
        CAST(FORMAT(time_out, 'hh') AS INT) % 12 * 5 + 
        FLOOR(CAST(FORMAT(time_out, 'mm') AS INT)/12.0) <
        (CAST(FORMAT(time_out, 'mm') AS INT) % 5 +1) * 12,
       IIF(NOT(CAST(FORMAT(time_out, 'mm') AS INT) % 5 = 
       FLOOR(CAST(FORMAT(time_out, 'mm') AS INT) / 12.0) AND
       FLOOR(CAST(FORMAT(time_out, 'mm') AS INT) /5.0) = 
       CAST(FORMAT(time_out, 'hh') AS INT)%12),
       2,
       0),
       0)+
   
    IIF( CAST(FORMAT(time_in, 'hh') AS INT)%12 * 5 + 
        FLOOR(CAST(FORMAT(time_in, 'mm') AS INT)/12.0) >=
        CAST(FORMAT(time_in, 'mm') AS INT) % 5 * 12 AND
        CAST(FORMAT(time_in, 'hh') AS INT) % 12 * 5 + 
        FLOOR(CAST(FORMAT(time_in, 'mm') AS INT)/12.0) <
        (CAST(FORMAT(time_in, 'mm') AS INT) % 5 +1) * 12,
       IIF(NOT(CAST(FORMAT(time_in, 'mm') AS INT) % 5 = 
       FLOOR(CAST(FORMAT(time_in, 'mm') AS INT) / 12.0) AND
       FLOOR(CAST(FORMAT(time_in, 'mm') AS INT) /5.0) = 
       CAST(FORMAT(time_in, 'hh') AS INT)%12),
       3,
       0),
       0) t
FROM
   Trip t1
)
SELECT 
   trip_no,
   CASE t
   WHEN 2 THEN 'D'
   WHEN 3 THEN 'A'
   WHEN 5 THEN 'DA'
   END  
FROM 
   dsT
WHERE
  t > 0

Задание: 58 (qwrqwr: 2013-03-01) 
Беглый заключенный, оказавшись в аэропорту города town_from, улетел ближайшим рейсом. 
Для каждого города town_from в Trip рассчитать вероятность того, что беглец окажется в городе town_to. Если в одно время из аэропорта вылетают несколько рейсов, считать возможность выбора заключенным каждого из этих рейсов равновероятной. 
Вывод: town_from, town_to, вероятность в процентах (число с точностью до тысячных долей).
WITH
dsT1 AS
(
SELECT
   t.town_from,
   t.time_out,
   IIF(LAG(time_out) OVER (PARTITION BY town_from ORDER BY time_out) IS NULL,
      FIRST_VALUE(time_out) OVER (PARTITION BY town_from ORDER BY time_out DESC),
       LAG(time_out) OVER (PARTITION BY town_from ORDER BY time_out)
      ) time,
  COUNT(time_out) c  
FROM
   Trip t
GROUP BY 
   t.town_from,
   t.time_out
),
dsT2 AS
(
SELECT 
  town_from,
  time_out,
  time,
  DATEDIFF(minute, 
           time, 
           DATEADD(DAY, IIF(time_out <= time, 1, 0), time_out)
          ) sum,
   c
FROM
   dsT1
)SELECT
   t.town_from,
   t.town_to,
   CAST(SUM(CAST(t2.sum AS NUMERIC(7,3))/c)/1.0/
        SUM(SUM(CAST(t2.sum AS NUMERIC(7,3))/c)) OVER (PARTITION BY t.town_from)/1.0*100
    AS NUMERIC(7,3)
       )
FROM
   Trip t
  INNER JOIN dsT2 t2 ON t2.town_from = t.town_from AND t2.time_out = t.time_out
GROUP BY 
   t.town_from,
   t.town_to

***/
