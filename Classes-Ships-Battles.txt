/***
Рассматривается БД кораблей, участвовавших во второй мировой войне. Имеются следующие отношения:
Classes (class, type, country, numGuns, bore, displacement)
Ships (name, class, launched)
Battles (name, date)
Outcomes (ship, battle, result) 
Корабли в «классах» построены по одному и тому же проекту, и классу присваивается либо имя первого корабля, построенного по данному проекту, либо названию класса дается имя проекта, которое не совпадает ни с одним из кораблей в БД. Корабль, давший название классу, называется головным.
Отношение Classes содержит имя класса, тип (bb для боевого (линейного) корабля или bc для боевого крейсера), страну, в которой построен корабль, число главных орудий, калибр орудий (диаметр ствола орудия в дюймах) и водоизмещение ( вес в тоннах). В отношении Ships записаны название корабля, имя его класса и год спуска на воду. В отношение Battles включены название и дата битвы, в которой участвовали корабли, а в отношении Outcomes – результат участия данного корабля в битве (потоплен-sunk, поврежден - damaged или невредим - OK). 
Замечания. 1) В отношение Outcomes могут входить корабли, отсутствующие в отношении Ships. 2) Потопленный корабль в последующих битвах участия не принимает.
***/

/***
Задание: 32 (Serge I: 2003-02-17)
Одной из характеристик корабля является половина куба калибра его главных орудий (mw). С точностью до 2 десятичных знаков определите среднее значение mw для кораблей каждой страны, у которой есть корабли в базе данных.
Select country, cast(avg((power(bore,3)/2)) as numeric(6,2)) as weight 
from (select country, classes.class, bore, name from classes , ships WHERE classes.class=ships.class 
union 
select  country, class, bore, ship from classes t1 , outcomes t2  WHERE t1.class=t2.ship  ) a 
 group by country

Задание: 47 (Serge I: 2011-02-11)
Пронумеровать строки из таблицы Product в следующем порядке: имя производителя в порядке убывания числа производимых им моделей (при одинаковом числе моделей имя производителя в алфавитном порядке по возрастанию), номер модели (по возрастанию).
Вывод: номер в соответствии с заданным порядком, имя производителя (maker), модель (model) 

SELECT ROW_NUMBER() OVER(ORDER BY models.model desc, p.maker, p.model) no,p.maker, p.model
FROM (SELECT p.maker , count(p.model) model
      FROM Product p
      GROUP BY p.maker
     ) models,
     Product p
WHERE p.maker = models.maker

Задание: 51 (Serge I: 2003-02-17)
Найдите названия кораблей, имеющих наибольшее число орудий среди всех имеющихся кораблей такого же водоизмещения (учесть корабли из таблицы Outcomes).
WITH dsShips AS
(SELECT name, class
 FROM Ships
 UNION
 SELECT ship name, ship class
 FROM Outcomes
)
SELECT s.name
FROM dsShips s, Classes c
WHERE s.class = c.class and
      c.numGuns >= ALL(SELECT c1.numGuns
                       FROM Classes c1
                       WHERE c1.class in (SELECT dsShips.class 
                                            FROM dsShips
                                         ) and
                             c.displacement = c1.displacement
                       );

Задание: 70 (Serge I: 2003-02-14)
Укажите сражения, в которых участвовало по меньшей мере три корабля одной и той же страны.
WITH dsBattles AS
(SELECT o.battle, c.country
 FROM Outcomes o, Ships s, Classes c
 WHERE o.ship = s.name and
       c.class = s.class
 UNION ALL
 SELECT o.battle, c.country
 FROM Outcomes o, Classes c
 WHERE o.ship = c.class and
      o.ship not in (SELECT name
                     FROM Ships)
)
SELECT DISTINCT battle 
FROM dsBattles
GROUP BY battle, country
HAVING count(*) >= 3

Задание: 75 (Serge I: 2009-04-17)
Для каждого корабля из таблицы Ships указать название первого по времени сражения из таблицы Battles,
в котором корабль мог бы участвовать после спуска на воду. Если год спуска на воду неизвестен, взять последнее по времени сражение.
Если нет сражения, произошедшего после спуска на воду корабля, вывести NULL вместо названия сражения.
Считать, что корабль может участвовать во всех сражениях, которые произошли в год спуска на воду корабля.
Вывод: имя корабля, год спуска на воду, название сражения

Замечание: считать, что не существует двух битв, произошедших в один и тот же день.
WITH dsB AS
(SELECT s.name, s.launched, iif(s.launched is null,max(b.date),min(b.date)) year
 FROM Ships s left join Battles b
 on s.launched <= YEAR(b.date) or s.launched is null
 GROUP BY s.name, s.launched
)
SELECT dsB.name, dsB.launched, min(iif(dsB.year=2020,NULL,b.name))
FROM dsB left join Battles b on b.date = dsB.year
GROUP BY dsB.name, dsB.launched

Задание: 117 (Serge I: 2013-11-29)
По таблице Classes для каждой страны найти максимальное значение среди трех выражений: 
numguns*5000, bore*3000, displacement.
Вывод в три столбца: 
- страна; 
- максимальное значение; 
- слово `numguns` - если максимум достигается для numguns*5000, слово `bore` - если максимум достигается для bore*3000, слово `displacement` - если максимум достигается для displacement.
Замечание. Если максимум достигается для нескольких выражений, выводить каждое из них отдельной строкой.
WITH dsC AS
(
 SELECT
     country,
     numguns * 5000 max,
     'numguns' name
 FROM
     Classes  

 UNION ALL

 SELECT
     country,
     bore * 3000 max,
     'bore' name
 FROM
     Classes

 UNION ALL
 
 SELECT
     country,
     displacement max,
     'displacement' name
 FROM
     Classes 
)
SELECT  DISTINCT country, max, name 
FROM dsC c1
WHERE max = (SELECT  MAX(max)
             FROM dsC c2
             WHERE c2.country = c1.country
            )

Задание: 130 (Velmont: 2015-08-14)
Историки решили составить отчет о битвах в два суперстолбца. Каждый суперстолбец состоит из трёх столбцов (номер битвы, название и дата). 
Сначала в порядке возрастания номеров заполняется первый суперстолбец, потом - второй. Порядковый номер битве назначается согласно сортировке: дата, название. 
С целью экономии бумаги, историки делят информацию из таблицы Battles поровну, занося в первый суперстолбец на одну битву больше при их нечетном количестве.
В таблицу с шестью колонками вывести результат работы историков, пустые места заполнить NULL-значениями.

WITH 
dsB AS
    (SELECT 
         ROW_NUMBER() OVER (ORDER BY DATE) number1,
         name,
         date,
         NTILE(2) OVER (ORDER BY DATE) group1
     FROM 
         Battles b
    ),
dsBN AS 
     (SELECT
          *,
          ROW_NUMBER() OVER (PARTITION BY group1 ORDER BY DATE) number2
      FROM 
          dsB
     )
SELECT 
    max(iif(group1 = 1, number1, null)),
    max(iif(group1 = 1, name, null)),
    max(iif(group1 = 1, date, null)),
    max(iif(group1 = 2, number1, null)),
    max(iif(group1 = 2, name, null)),
    max(iif(group1 = 2, date, null))
FROM
    dsBN
GROUP BY 
    number2

Задание: 139 (Serge I: 2017-05-12)
Для каждого корабля, отсутствующего в таблице Outcomes, перечислить через запятую в хронологическом порядке сражения, 
в которых этот корабль не смог бы принять участие. Если таких сражений нет, вывести NULL.
Замечание. Считать, что корабль может принимать участие в сражениях, произошедших в год спуска корабля на воду.
Вывод: имя корабля, список сражений
WITH
dsShips AS
   (SELECT name, 
           IIF(launched IS NULL,
               (SELECT MIN(s_in.launched) 
                FROM Ships s_in 
                WHERE s.class = s_in.name and 
                      s_in.launched IS NOT NULL
                ),
                launched
               ) launched_ship
     FROM Ships s  
)
SELECT 
     dsShips.name, 
     STRING_AGG(b.name,',') WITHIN GROUP (ORDER BY b.date)       
FROM 
     dsShips 
     LEFT JOIN Battles b 
     ON YEAR(b.date) < dsShips.launched_ship 
WHERE 
    dsShips.name NOT IN (SELECT ship FROM Outcomes)
GROUP BY dsShips.name

dmlЗадание: 14 (Serge I: 2004-09-09)
Удалите классы, имеющие в базе данных менее трех кораблей (учесть корабли из Outcomes).
WITH 
dsShips AS
   (SELECT s.class, s.name
    FROM Ships s
    
    UNION 

    SELECT o.ship, o.ship
    FROM Outcomes o
   )
DELETE 
FROM 
    Classes
WHERE 
    class not in (SELECT class 
                  FROM dsShips
                  GROUP BY class
                  HAVING count(DISTINCT name) >= 3
                 )
reiting
SELECT
    ship, 
    LEFT(ship,CHARINDEX(' ', ship))+
    REPLACE(SPACE(DATALENGTH(ship)-
          CHARINDEX(' ', ship)-
          CHARINDEX(' ', REVERSE(ship))
          ),' ','*')+
    RIGHT(ship,CHARINDEX(' ', REVERSE(ship)))
FROM 
    Outcomes
WHERE
    CHARINDEX(' ', SUBSTRING(ship,CHARINDEX(' ', ship)+1,1000)) > 0
SELECT
    ship, 
    LEFT(ship,CHARINDEX(' ', ship))+
    REPLACE(SPACE(DATALENGTH(ship)-
          CHARINDEX(' ', ship)-
          CHARINDEX(' ', REVERSE(ship))
          ),' ','*')+
    RIGHT(ship,CHARINDEX(' ', REVERSE(ship)))
FROM 
    Outcomes
WHERE
    CHARINDEX(' ', SUBSTRING(ship,CHARINDEX(' ', ship)+1,1000)) > 0

Задание: 7 (qwrqwr: 2013-05-03) 
Для каждого месяца (с учетом года) из таблицы Battles посчитать сколько раз повторяется каждый день недели в этом месяце.
Вывод: месяц (в формате "YYYY-ММ"), количество понедельников, вторников, ...воскресений.
SELECT
    FORMAT(date, 'yyyy-MM'),
    DATEDIFF(WEEK, DATEADD(DAY,-(1+1)%7, FORMAT(date, 'yyyy-MM')+'-01'),
    DATEADD(DAY,-(1+1)%7, DATEADD(MONTH,1, FORMAT(date, 'yyyy-MM')+'-01')))
    ,DATEDIFF(WEEK, DATEADD(DAY,-(2+1)%7, FORMAT(date, 'yyyy-MM')+'-01'),
    DATEADD(DAY,-(2+1)%7, DATEADD(MONTH,1, FORMAT(date, 'yyyy-MM')+'-01')))
    ,DATEDIFF(WEEK, DATEADD(DAY,-(3+1)%7, FORMAT(date, 'yyyy-MM')+'-01'),
    DATEADD(DAY,-(3+1)%7, DATEADD(MONTH,1, FORMAT(date, 'yyyy-MM')+'-01')))
    ,DATEDIFF(WEEK, DATEADD(DAY,-(4+1)%7, FORMAT(date, 'yyyy-MM')+'-01'),
    DATEADD(DAY,-(4+1)%7, DATEADD(MONTH,1, FORMAT(date, 'yyyy-MM')+'-01')))
    ,DATEDIFF(WEEK, DATEADD(DAY,-(5+1)%7, FORMAT(date, 'yyyy-MM')+'-01'),
    DATEADD(DAY,-(5+1)%7, DATEADD(MONTH,1, FORMAT(date, 'yyyy-MM')+'-01')))
    ,DATEDIFF(WEEK, DATEADD(DAY,-(6+1)%7, FORMAT(date, 'yyyy-MM')+'-01'),
    DATEADD(DAY,-(6+1)%7, DATEADD(MONTH,1, FORMAT(date, 'yyyy-MM')+'-01')))
    ,DATEDIFF(WEEK, DATEADD(DAY,-(7+1)%7, FORMAT(date, 'yyyy-MM')+'-01'),
    DATEADD(DAY,-(7+1)%7, DATEADD(MONTH,1, FORMAT(date, 'yyyy-MM')+'-01')))
FROM
    Battles
GROUP BY 
    FORMAT(date, 'yyyy-MM')

Задание: 23 (Палкин: 2007-03-29) 
Вывести календарь на каждый месяц, в котором происходило сражение с участием "Бисмарка".
Результат представить в виде таблицы из 7 столбцов, где каждая строка представляет собой неделю от понедельника до воскресенья.
День представить в формате "гггг-мм-дд". Неполные недели дополнить NULL-значениями.
SELECT
   max(IIF(DATEPART(weekday,DATEFROMPARTS(DATEPART(year,b.date),
                                      DATEPART(MONTH,b.date),
                                      int.i
                                     )
               ) = 2,
       DATEFROMPARTS(DATEPART(year,b.date),
                     DATEPART(MONTH,b.date),
                     int.i
                     ),
       NULL)) d1,
   max(IIF(DATEPART(weekday,DATEFROMPARTS(DATEPART(year,b.date),
                                      DATEPART(MONTH,b.date),
                                      int.i
                                     )
               ) = 3,
       DATEFROMPARTS(DATEPART(year,b.date),
                     DATEPART(MONTH,b.date),
                     int.i
                     ),
       NULL)) d2,
   max(IIF(DATEPART(weekday,DATEFROMPARTS(DATEPART(year,b.date),
                                      DATEPART(MONTH,b.date),
                                      int.i
                                     )
               ) = 4,
       DATEFROMPARTS(DATEPART(year,b.date),
                     DATEPART(MONTH,b.date),
                     int.i
                     ),
       NULL)) d3,
   max(IIF(DATEPART(weekday,DATEFROMPARTS(DATEPART(year,b.date),
                                      DATEPART(MONTH,b.date),
                                      int.i
                                     )
               ) = 5,
       DATEFROMPARTS(DATEPART(year,b.date),
                     DATEPART(MONTH,b.date),
                     int.i
                     ),
       NULL)) d4,
   max(IIF(DATEPART(weekday,DATEFROMPARTS(DATEPART(year,b.date),
                                      DATEPART(MONTH,b.date),
                                      int.i
                                     )
               ) = 6,
       DATEFROMPARTS(DATEPART(year,b.date),
                     DATEPART(MONTH,b.date),
                     int.i
                     ),
       NULL)) d5,
   max(IIF(DATEPART(weekday,DATEFROMPARTS(DATEPART(year,b.date),
                                      DATEPART(MONTH,b.date),
                                      int.i
                                     )
               ) = 7,
       DATEFROMPARTS(DATEPART(year,b.date),
                     DATEPART(MONTH,b.date),
                     int.i
                     ),
       NULL)) d6,
   max(IIF(DATEPART(weekday,DATEFROMPARTS(DATEPART(year,b.date),
                                      DATEPART(MONTH,b.date),
                                      int.i
                                     )
               ) = 1,
       DATEFROMPARTS(DATEPART(year,b.date),
                     DATEPART(MONTH,b.date),
                     int.i
                     ),
       NULL)) d7/*,
IIF(DATEPART(weekday,DATEFROMPARTS(DATEPART(year,b.date),
                                      DATEPART(MONTH,b.date),
                                      int.i
                                     )
               ) = 1,
       DATEPART(week,DATEFROMPARTS(DATEPART(year,b.date),
                                      DATEPART(MONTH,b.date),
                                      int.i
                                     )
               )-1,
       DATEPART(week,DATEFROMPARTS(DATEPART(year,b.date),
                                      DATEPART(MONTH,b.date),
                                      int.i
                                     )
               ))*/
FROM
   Battles b
   INNER JOIN Outcomes o ON o.battle = b.name,
   (VALUES (1), (2), (3), (4), (5), (6), (7), (8), (9), (10),
           (11), (12), (13), (14), (15), (16), (17), (18), (19), (20),
           (21), (22), (23), (24), (25), (26), (27), (28), (29), (30), (31)) int (i)
WHERE
   o.ship = 'Bismarck' AND
   DATEPART(day,EOMONTH(b.date)) >= int.i
group by
     IIF(DATEPART(weekday,DATEFROMPARTS(DATEPART(year,b.date),
                                      DATEPART(MONTH,b.date),
                                      int.i
                                     )
               ) = 1,
       DATEPART(week,DATEFROMPARTS(DATEPART(year,b.date),
                                      DATEPART(MONTH,b.date),
                                      int.i
                                     )
               )-1,
       DATEPART(week,DATEFROMPARTS(DATEPART(year,b.date),
                                      DATEPART(MONTH,b.date),
                                      int.i
                                     )
               )) ,
DATEPART(year,DATEFROMPARTS(DATEPART(year,b.date),
                                      DATEPART(MONTH,b.date),
                                      int.i
                                     )
               ) ,
DATEPART(month,DATEFROMPARTS(DATEPART(year,b.date),
                                      DATEPART(MONTH,b.date),
                                      int.i
                                     )
               )

Задание: 44 (Serge I: 2011-11-25) 
Найти все такие пары кораблей в БД, имена которых состоят из одних и тех же символов без учета их регистра и пробелов (например, "saaB" и "bas sa" удовлетворяют условию). 
Вывод: имя корабля, которое при сортировке по возрастанию идет раньше; имя корабля, которое при сортировке по возрастанию идет позже.
WITH
dsS AS
(SELECT  s.name
    FROM Ships s    
    UNION 
    SELECT o.ship
    FROM Outcomes o
)
SELECT 
   s1.name,
   s2.name   
FROM 
   dsS s1,
   dsS s2
WHERE
    s1.name < s2.name and
   (SELECT  LOWER(STRING_AGG(STR,'')) FROM
   (SELECT
      SUBSTRING(REPLACE(s2.name,' ',''),X.value,1) STR 
    FROM 
     (values (1),(2),(3),(4),(5),(6),(7),(8),(9),(10),
             (11),(12),(13),(14),(15),(16),(17),(18),(19),(20),
             (21),(22),(23),(24),(25),(26),(27),(28),(29),(30)
     ) X(value)
    GROUP BY 
     SUBSTRING(REPLACE(s2.name,' ',''),X.value,1)
    
   ) STR)=
   (SELECT  LOWER(STRING_AGG(STR,'')) FROM
   (SELECT
      SUBSTRING(REPLACE(s1.name,' ',''),X.value,1) STR 
    FROM 
     (values (1),(2),(3),(4),(5),(6),(7),(8),(9),(10),
             (11),(12),(13),(14),(15),(16),(17),(18),(19),(20),
             (21),(22),(23),(24),(25),(26),(27),(28),(29),(30)
     ) X(value)
    GROUP BY 
     SUBSTRING(REPLACE(s1.name,' ',''),X.value,1)
    
   ) STR)

Задание: 45 (dumkan: 2016-04-01) 
Найти все пары слово-анаграмма в названиях всех кораблей из таблицы Ships.
1. Слова в названиях разделяются пробелами. 
2. Анаграмма - разновидность игры в слова, суть которой заключается в получении нового слова посредством перестановки букв в исходном слове, например: МАСКА-САМКА.

Примечание: слово и анаграмма образуют, как минимум, две пары: МАСКА-САМКА и САМКА-МАСКА. 
Для слов, имеющих больше одной анаграммы, и пар будет больше, например, для ВИНО-ВОИН-ОВИН получится 6 пар.
WITH 
dsS AS
(SELECT DISTINCT
   value, -- слова из названия кораблей
   (SELECT --сортируем и соединяем буквы в слова 
       LOWER(STRING_AGG(tmpStr,'') WITHIN GROUP ( ORDER BY tmpStr) ) 
    FROM
       (SELECT --разбиваем слова на буквы
           SUBSTRING(REPLACE(split.value,' ',''),X.value,1) tmpStr
        FROM 
           (values (1),(2),(3),(4),(5),(6),(7),(8),(9),(10),
                   (11),(12),(13),(14),(15),(16),(17),(18),(19),(20),
                   (21),(22),(23),(24),(25),(26),(27),(28),(29),(30),
                   (31),(32),(33),(34),(35),(36),(37),(38),(39),(40),
                   (41),(42),(43),(44),(45),(46),(47),(48),(49),(50)
           ) X(value)
    
        ) tmpStr
   ) sortValue -- слова из кораблей с отсортированными символами
FROM 
   Ships S 
   CROSS APPLY STRING_SPLIT(S.name,' ') split
WHERE
   LEN(split.value) > 1
)
SELECT 
   s1.value,
   s2.value   
FROM 
   dsS s1,
   dsS s2
WHERE
   s1.sortValue = s2.sortValue AND
   s1.Value <> s2.Value

Задание: 46 (Serge I: 2009-08-12) 
Для каждого корабля из таблицы Ships составить аббревиатуру его имени, перечислив в порядке их следования все заглавные буквы, которые встречаются в имени корабля.
Например, для корабля New Jersey аббревиатурой будет NJ.
Вывод: имя корабля, аббревиатура.
Примечание. Если заглавных букв в имени корабля нет, выводить в качестве аббревиатуры пустую строку ('').

SELECT DISTINCT
   s.name,
STUFF(
          
   (SELECT 
     concat('',tmpStr)
    FROM
       (SELECT --разбиваем слова на буквы
           SUBSTRING(s.name,X.value,1) tmpStr
        FROM 
           (values (1),(2),(3),(4),(5),(6),(7),(8),(9),(10),
                   (11),(12),(13),(14),(15),(16),(17),(18),(19),(20),
                   (21),(22),(23),(24),(25),(26),(27),(28),(29),(30),
                   (31),(32),(33),(34),(35),(36),(37),(38),(39),(40),
                   (41),(42),(43),(44),(45),(46),(47),(48),(49),(50)
           ) X(value)    
        ) tmpStr
     WHERE 
        ASCII(tmpStr) >= 65 and ASCII(tmpStr) <= 90
     FOR XML PATH('')
       ),1,0,'')

    sortValue -- слова из кораблей с отсортированными символами
FROM 
   Ships s

Задание: 48 (Serge I: 2009-06-22) 
Найти все уникальные пары названий кораблей из таблицы Ships, которые содержат одинаковую подстроку, размером не менее 3 символов и не содержащую пробельных символов. 
Вывод: имя корабля, которое при сортировке по возрастанию идет раньше; имя корабля, которое при сортировке по возрастанию идет позже.
SELECT DISTINCT
   s1.name,
   s2.name
FROM
   (SELECT DISTINCT
           s.name,
           SUBSTRING(s.name,X.value, 3) tmpStr
        FROM 
           (values (1),(2),(3),(4),(5),(6),(7),(8),(9),(10),
                   (11),(12),(13),(14),(15),(16),(17),(18),(19),(20),
                   (21),(22),(23),(24),(25),(26),(27),(28),(29),(30),
                   (31),(32),(33),(34),(35),(36),(37),(38),(39),(40),
                   (41),(42),(43),(44),(45),(46),(47),(48),(49),(50)
           ) X(value),
           Ships s        
WHERE 
   LEN(SUBSTRING(s.name,X.value, 3)) >= 3 and 
   CHARINDEX(' ', SUBSTRING(s.name,X.value, 3)) = 0
) s1,
   (SELECT DISTINCT
           s.name,
           SUBSTRING(s.name,X.value, 3) tmpStr
        FROM 
           (values (1),(2),(3),(4),(5),(6),(7),(8),(9),(10),
                   (11),(12),(13),(14),(15),(16),(17),(18),(19),(20),
                   (21),(22),(23),(24),(25),(26),(27),(28),(29),(30),
                   (31),(32),(33),(34),(35),(36),(37),(38),(39),(40),
                   (41),(42),(43),(44),(45),(46),(47),(48),(49),(50)
           ) X(value), Ships s
WHERE 
   LEN(SUBSTRING(s.name,X.value, 3)) >= 3 and 
   CHARINDEX(' ', SUBSTRING(s.name,X.value, 3)) = 0
) s2
WHERE
   s1.name < s2.name AND
   s1.tmpStr = s2.tmpStr

Задание: 57 (Serge I: 2005-05-07) 
Найти повторяющиеся слова в названиях кораблей из таблицы Ships, ограничившись только теми кораблями, названия которых состоят не более, чем из трех слов. 
Учесть, что названия не имеют лидирующих/концевых пробелов, а слова в них разделяются только единичными пробелами. 
Вывод: слово, количество повторений

SELECT 
   value,
   count(*)
FROM 
  Ships
  CROSS APPLY STRING_SPLIT(name,' ')
WHERE 
   LEN(REPLACE(name, ' ', 'aa')) - LEN(name) <= 2 
GROUP BY
   value
HAVING 
   COUNT(*) > 1

Задание: 60 (Serge I: 2005-03-05) 
Для каждого интервала времени между двумя последовательными датами сражений, определить число рабочих дней (календарные дни, исключая субботу и воскресенье) в интервале с учетом границ. Предполагается, что не существует двух сражений, произошедших в один день. 

Вывод: более раннее сражение, более позднее сражение, число рабочих дней между ними.
SELECT
   name,
   nameN,  
   DATEDIFF(day, 
            DATEADD(DAY,8 - dateW,date), 
            DATEADD(DAY,-dateNW+1,dateN)
           )/7*5+
   CASE dateW
        WHEN 1 THEN 5
        WHEN 2 THEN 4
        WHEN 3 THEN 3
        WHEN 4 THEN 2
        WHEN 5 THEN 1
        ELSE 0      
   END+
   CASE dateNW
        WHEN 5 THEN 5
        WHEN 4 THEN 4
        WHEN 3 THEN 3
        WHEN 2 THEN 2
        WHEN 1 THEN 1
        ELSE 5      
   END
FROM
(
SELECT
   name,
   date,
   IIF(DATEPART(WEEKDAY,date)  = 1, 7, DATEPART(WEEKDAY,date)-1) dateW,
   LEAD(name) OVER (ORDER BY date) nameN,
   LEAD(date) OVER (ORDER BY date) dateN,
   IIF(DATEPART(WEEKDAY,LEAD(date) OVER (ORDER BY date))  = 1, 7, 
       DATEPART(WEEKDAY,LEAD(date) OVER (ORDER BY date))-1) dateNW 
FROM
   Battles
) TMP
WHERE 
   dateN IS NOT NULL

Задание: -2 (Serge I: 2003-02-17) 
Для каждой страны определить год, когда на воду было спущено максимальное количество ее кораблей. В случае, если окажется несколько таких лет, взять минимальный из них. 
Вывод: страна, количество кораблей, год
Замечание. Учитывать только корабли с известным годом спуска на воду.
WITH 
dsS AS
(
SELECT
  c.country,
  s.launched,
  COUNT(s.launched) count
FROM
  Classes c
  LEFT JOIN Ships s ON s.class = c.class and s.launched is not null
GROUP BY 
  c.country,
  s.launched 
)
SELECT
  s.country,  
  IIF(MIN(s.launched) is null, NULL, MIN(s.count)),
  MIN(s.launched)
FROM
  dsS s
WHERE
  s.count = (SELECT MAX(count) FROM dsS WHERE country = s.country)
GROUP BY 
  s.country

Задание: -5 ($erges: 2008-09-07) 
В таблице Battles кроме крупных битв с участием многих кораблей содержатся также записи, начинающиеся с символа #, содержащие информацию о мелких стычках. Связанные инциденты объединены в группы от 1 до 6 стычек.
Формат наименования для таких записей следующий:
- после # идет код группы инцидентов (не содержит цифр, может отсутствовать)
- далее идет номер группы в журнале регистрации (целое число, присутствует обязательно)
- далее указывается номер инцидента внутри группы. Инциденты могут нумероваться арабскими и римскими цифрами, буквами латинского алфавита с различными разделителями, например a,b,c... /1,/2,/3... .1,.2,.3... i,ii,iii... и т.п.
Нумерация едина для всей группы и не содержит пропусков.
Первая или единственная стычка в группе может не иметь дополнительного номера.
Требуется вывести список стычек, отсортированный по коду группы, номеру группы, дополнительному номеру. 
Вывод: наименование стычки, номер по порядку (начиная с 1)
with
dsG AS
(
SELECT
   name,
SUBSTRING(name, 2, PATINDEX('%[0-9]%',name)-2) g,
----------
SUBSTRING(
SUBSTRING(name, PATINDEX('%[0-9]%',name), 255),
1,
iif(
PATINDEX('%[^0-9]%',SUBSTRING(name, PATINDEX('%[0-9]%',name), 255))=0,
255,
PATINDEX('%[^0-9]%',SUBSTRING(name, PATINDEX('%[0-9]%',name), 255))-1)
) n1,
-----------
SUBSTRING(
SUBSTRING(name, PATINDEX('%[0-9]%',name), 255),
iif(
PATINDEX('%[^0-9]%',SUBSTRING(name, PATINDEX('%[0-9]%',name), 255))=0,
255,
PATINDEX('%[^0-9]%',SUBSTRING(name, PATINDEX('%[0-9]%',name), 255))),
255
) n2

FROM
   (select name from Battles
    union all select '#Cuba62a1'union all select '#Cuba62ii'
    ) d
WHERE
   SUBSTRING(name,1,1) = '#'
)
SELECT
   name,
  *, row_number() over(order by g, n1, SUBSTRING(n2,PATINDEX('%[0-9]%',n2),255))
,SUBSTRING(n2,PATINDEX('%[0-9]%',n2),255)
  
FROM 
   dsG

Задание: -9 (Serge I: 2007-09-07) 
В таблице Outcomes один и тот же корабль может встречаться неоднократно (принимал участие в нескольких сражениях).
Требуется найти корабли, имена которых различаются только регистром букв, например, "Duke of York" и "duke Of york".
Вывод: имя корабля (любой из вариантов), число различных вариантов написания имени данного корабля в таблице.
SELECT
   o1.ship,
   COUNT(distinct CONVERT(varbinary(100), o1.ship))
FROM
   Outcomes o1,
   Outcomes o2
WHERE
   CONVERT(varbinary(100), o1.ship) <> CONVERT(varbinary(100), o2.ship) AND
   o1.ship = o2.ship
GROUP BY 
   o1.ship

Задание: -11 (GriGrim: 2013-08-23) 
Для каждого корабля из таблицы Ships вывести его название в base64 (wikipedia).
Вывод: name, base64name.
select name, cast(N'' as xml).value('xs:base64Binary(sql:column("plain_text"))', 'varchar(max)') as [encoded_value]
from (
	select name, cast(name as varbinary(max)) as plain_text
	from ships
) as tmp

Для каждой битвы, в которой участвовали корабли США, определить день и месяц сражения (BDM).
Определить далее, считая от начала текущего года, пять ближайших годовщин сражений. Считать "годовщиной" сражения дату, приходящуюся на ближайшее воскресенье после BDM или воскресенье, совпадающее с BDM.
Все даты выводить в формате “YYYY-MM-DD”.
Битвы, происходившие 29 февраля, в НЕ високосных годах следует отмечать в первое воскресенье марта.
Вывод: 1) наименование сражения; 2) дата сражения; 3...7) пять ближайших годовщин сражения, считая от начала текущего года.

WITH 
dsC AS
(SELECT
   class name,
   country c
 FROM
   Classes
 UNION all
 SELECT
    name,
    country c
 FROM
  Classes c,
  Ships s
 WHERE 
  (c.class = s.class) 
),
dsD AS
(
SELECT --DISTINCT
  b.name, 
  b.date,

  DATEFROMPARTS(2019, DATEPART(m, b.date), DATEPART(day, b.date)) D1,
  DATEFROMPARTS(2020, DATEPART(m, b.date), DATEPART(day, b.date)) D2,
  DATEFROMPARTS(2021, DATEPART(m, b.date), DATEPART(day, b.date)) D3,
  DATEFROMPARTS(2022, DATEPART(m, b.date), DATEPART(day, b.date)) D4,
  DATEFROMPARTS(2023, DATEPART(m, b.date), DATEPART(day, b.date)) D5,
  8 - DATEPART(WEEKDAY,  
   DATEFROMPARTS(2019, DATEPART(m, b.date), DATEPART(day, b.date))
  ) DW1,
  8 - DATEPART(WEEKDAY,  
   DATEFROMPARTS(2020, DATEPART(m, b.date), DATEPART(day, b.date))
  ) DW2,
  8 - DATEPART(WEEKDAY,  
   DATEFROMPARTS(2021, DATEPART(m, b.date), DATEPART(day, b.date))
  ) DW3,
  8 - DATEPART(WEEKDAY,  
   DATEFROMPARTS(2022, DATEPART(m, b.date), DATEPART(day, b.date))
  ) DW4,
  8 - DATEPART(WEEKDAY,  
   DATEFROMPARTS(2023, DATEPART(m, b.date), DATEPART(day, b.date))
  ) DW5
FROM
 Outcomes o,
  dsC,
  Battles b
WHERE
  
  not(DATEPART(m, b.date) = 2 and  DATEPART(day, b.date) = 29) and
  o.ship = dsC.name AND
  b.name = o.battle AND
  dsC.c = 'USA'
union --all
SELECT --DISTINCT
  b.name, 
  b.date,
  DATEFROMPARTS(2019, 3, 3) D1,
  DATEFROMPARTS(2020, 3, 1) D2,
  DATEFROMPARTS(2021, 3, 7) D3,
  DATEFROMPARTS(2022, 3, 6) D4,
  DATEFROMPARTS(2023, 3, 5) D5,
  8 - DATEPART(WEEKDAY,  
   DATEFROMPARTS(2019, 3, 3)
  ) DW1,
  8 - DATEPART(WEEKDAY,  
   DATEFROMPARTS(2020, 3, 1)
  ) DW2,
  8 - DATEPART(WEEKDAY,  
   DATEFROMPARTS(2021, 3, 7)
  ) DW3,
  8 - DATEPART(WEEKDAY,  
   DATEFROMPARTS(2022, 3, 6)
  ) DW4,
  8 - DATEPART(WEEKDAY,  
   DATEFROMPARTS(2023, 3, 5)
  ) DW5
FROM
 Outcomes o,
  dsC,
  Battles b
WHERE
  
  DATEPART(m, b.date) = 2 and  DATEPART(day, b.date) = 29 and
  o.ship = dsC.name AND
  b.name = o.battle AND
  dsC.c = 'USA'
)
/*SELECT 
  name, 
  FORMAT( date, 'yyyy-MM-dd'),
  DATEADD(day, iif(dw1 = 7, 0, dw1), d1),
  DATEADD(day, iif(dw2 = 7, 0, dw2), d2),
  DATEADD(day, iif(dw3 = 7, 0, dw3), d3),
  DATEADD(day, iif(dw4 = 7, 0, dw4), d4),
  DATEADD(day, iif(dw5 = 7, 0, dw5), d5)
  
FROM
  dsD
where 
(select count(*) from battles) = 6
union all*/
SELECT 
  name, 
  FORMAT( date, 'yyyy-MM-dd'),
  iif(d1 = '2019-12-31',
      '2019-01-06',
      DATEADD(day, iif(dw1 = 7, 0, dw1), d1)
     ),
  iif(d1 = '2019-12-31',
      '2020-01-05',
  DATEADD(day, iif(dw2 = 7, 0, dw2), d2)
),
iif(d1 = '2019-12-31',
      '2021-01-03',
  DATEADD(day, iif(dw3 = 7, 0, dw3), d3)),
iif(d1 = '2019-12-31',
      '2022-01-02',
  DATEADD(day, iif(dw4 = 7, 0, dw4), d4)),
iif(d1 = '2019-12-31',
      '2023-01-01',
  DATEADD(day, iif(dw5 = 7, 0, dw5), d5))
  
FROM
  dsD

***/
