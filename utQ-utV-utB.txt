/***
Схема базы данных состоит из трех отношений:
utQ (Q_ID int, Q_NAME varchar(35)); utV (V_ID int, V_NAME varchar(35), V_COLOR char(1)); utB (B_Q_ID int, B_V_ID int, B_VOL tinyint, B_DATETIME datetime).
Таблица utQ содержит идентификатор и название квадрата, цвет которого первоначально черный.
Таблица utV содержит идентификатор, название и цвет баллончика с краской.
Таблица utB содержит информацию об окраске квадрата баллончиком: идентификатор квадрата, идентификатор баллончика, количество краски и время окраски.
При этом следует иметь в виду, что:
- баллончики с краской могут быть трех цветов - красный V_COLOR='R', зеленый V_COLOR='G', голубой V_COLOR='B' (латинские буквы).
- объем баллончика равен 255 и первоначально он полный;
- цвет квадрата определяется по правилу RGB, т.е. R=0,G=0,B=0 - черный, R=255, G=255, B=255 - белый;
- запись в таблице закрасок utB уменьшает количество краски в баллончике на величину B_VOL и соответственно увеличивает количество краски в квадрате на эту же величину;
- значение 0 < B_VOL <= 255;
- количество краски одного цвета в квадрате не превышает 255, а количество краски в баллончике не может быть меньше нуля;
- время окраски B_DATETIME дано с точностью до секунды, т.е. не содержит миллисекунд.***/

/***
Задание: 92 (ZrenBy: 2003-09-01)
Выбрать все белые квадраты, которые окрашивались только из баллончиков, 
пустых к настоящему времени. Вывести имя квадрата
SELECT DISTINCT q.Q_NAME
FROM utB b, utQ q
WHERE b.B_Q_ID = q.Q_ID and
      b.B_Q_ID in (SELECT B1.B_Q_ID
                   FROM utB b1, utV v1
                   WHERE b1.B_V_ID = v1.V_ID
                   GROUP BY B1.B_Q_ID
                   HAVING sum(iif(v1.V_COLOR = 'R', b1.B_VOL, 0))>=255 and
                          sum(iif(v1.V_COLOR = 'G', b1.B_VOL, 0))>=255 and
                          sum(iif(v1.V_COLOR = 'B', b1.B_VOL, 0))>=255
                  ) and
 b.B_Q_ID not in (SELECT B1.B_Q_ID
                   FROM utB b1, utV v1
                   WHERE b1.B_V_ID = v1.V_ID and
                   v1.V_ID not in (SELECT B2.B_V_ID
                                   FROM utB b2
                                   GROUP BY B2.B_V_ID
                                   HAVING SUM(B2.B_VOL) >= 255
                                  )
                  )

Задание: 106 (Baser: 2013-09-06)
Пусть v1, v2, v3, v4, ... представляет последовательность вещественных чисел - объемов окрасок b_vol, упорядоченных по возрастанию b_datetime, b_q_id, b_v_id. 
Найти преобразованную последовательность P1=v1, P2=v1/v2, P3=v1/v2*v3, P4=v1/v2*v3/v4, ..., где каждый следующий член получается из предыдущего умножением на vi (при нечетных i) или делением на vi (при четных i). 
Результаты представить в виде b_datetime, b_q_id, b_v_id, b_vol, Pi, где Pi - член последовательности, соответствующий номеру записи i. Вывести Pi с 8-ю знаками после запятой.
WITH dsP AS
(SELECT b_datetime, 
        b_q_id, 
        b_v_id, 
        B_VOL,
        ROW_NUMBER() OVER (ORDER BY b_datetime, b_q_id, b_v_id) pow
 FROM utB
)
SELECT b_datetime, 
       b_q_id, 
       b_v_id, 
       B_VOL,
       cast(exp(sum(log(iif(pow % 2 = 0,1.0/cast(B_VOL as decimal(18,8)  ),B_VOL))) OVER (ORDER BY b_datetime, b_q_id, b_v_id)) as decimal(18,8))
FROM dsP
Задание: 116 (Velmont: 2013-11-19)
Считая, что каждая окраска длится ровно секунду, определить непрерывные интервалы времени с длительностью более 1 секунды из таблицы utB.
Вывод: дата первой окраски в интервале, дата последней окраски в интервале.
WITH cte AS (SELECT B_DATETIME, 
	DATEADD(ss, -1 * DENSE_RANK() OVER(ORDER BY B_DATETIME), B_DATETIME) AS grp
	FROM utB
)

SELECT MIN(B_DATETIME), MAX(B_DATETIME)
FROM cte
GROUP BY grp
HAVING COUNT(DISTINCT B_DATETIME) >  1

Задание: 119 ($erges: 2008-04-25)
Сгруппировать все окраски по дням, месяцам и годам. Идентификатор каждой группы должен иметь вид "yyyy" для года, "yyyy-mm" для месяца и "yyyy-mm-dd" для дня.
Вывести только те группы, в которых количество различных моментов времени (b_datetime), когда выполнялась окраска, более 10.
Вывод: идентификатор группы, суммарное количество потраченной краски.
SELECT FORMAT(B_DATETIME, 'yyyy'),
       SUM(B_VOL)
  FROM utB
 GROUP BY FORMAT(B_DATETIME, 'yyyy')
HAVING COUNT(DISTINCT B_DATETIME) > 10
 UNION all
SELECT FORMAT(B_DATETIME, 'yyyy-MM'),
       SUM(B_VOL)      
FROM utB
GROUP BY FORMAT(B_DATETIME, 'yyyy-MM')
HAVING COUNT(DISTINCT B_DATETIME) > 10
     UNION all
SELECT FORMAT(B_DATETIME, 'yyyy-MM-dd'),
       SUM(B_VOL)      
FROM utB
GROUP BY FORMAT(B_DATETIME, 'yyyy-MM-dd')
HAVING COUNT(DISTINCT B_DATETIME) > 10

Задание: 112 (Serge I: 2003-12-24)
Какое максимальное количество черных квадратов можно было бы окрасить в белый цвет
оставшейся краской

with cte as (
select ((count(distinct [V_ID]) * 255 - sum([B_VOL]))/ 255) as fv
from utv left join [dbo].[utB] on [utB].[B_V_ID] = [utV].[V_ID]
group by [V_COLOR])
select iif(count(*)=3,min(fv),0) as qty from cte

Задание: 113 (Serge I: 2003-12-24)
Сколько каждой краски понадобится, чтобы докрасить все Не белые квадраты до белого цвета.
Вывод: количество каждой краски в порядке (R,G,B)
with cte1 as (
select 
     iif(v_color = 'R',
           (select count (*) from utQ) * 255- sum(coalesce([B_VOL],0)),
           0) as r,
     iif(v_color = 'G',
           (select count (*) from utQ) * 255- sum(coalesce([B_VOL],0)),
           0) as g,
     iif(v_color = 'B',
           (select count (*) from utQ) * 255- sum(coalesce([B_VOL],0)),
           0) as b
from utv, utB
where  utb.b_v_ID = utv.v_ID
group by v_color
)
select sum(r), sum(g), sum(b) from cte1

Задание: 115 (Baser: 2013-11-01)
Рассмотрим равнобочные трапеции, в каждую из которых можно вписать касающуюся всех сторон окружность. Кроме того, каждая сторона имеет целочисленную длину из множества значений b_vol. 
Вывести результат в 4 колонки: Up, Down, Side, Rad. Здесь Up - меньшее основание, Down - большее основание, Side - длины боковых сторон, Rad – радиус вписанной окружности (с 2-мя знаками после запятой).
SELECT
    DISTINCT
    b1.b_vol,
    b2.b_vol,
    b3.b_vol,
    CAST(SQRT(1.0 * b1.b_vol * b2.b_vol) / 2 AS NUMERIC(8, 2))
FROM 
    utB b1,
    utB b2,
    utB b3
WHERE 
    b1.b_vol < b2.b_vol and
    b3.b_vol = (1.0 * b1.b_vol + 1.0 * b2.b_vol) / 2
Задание: 134 (Serge I: 2003-12-26)
Выполняется докраска квадратов до белого цвета каждым цветом по следующей схеме:
- сначала закрашиваются квадраты, для которых требуется меньше краски соответствующего цвета;
- при одинаковом необходимом количестве краски сначала закрашиваются квадраты с меньшим q_id.
Найти идентификаторы НЕ белых квадратов, оставшихся после израсходования всей краски.
--неоходимо красох по цветам
WITH
dsNeed AS
    (SELECT
         q.Q_ID,
         q.col color,
         255-SUM(COALESCE(b.B_VOL,0)) need,
         SUM(255-SUM(COALESCE(b.B_VOL,0))) 
               OVER (PARTITION BY q.col ORDER BY 
                         255-SUM(COALESCE(b.B_VOL,0)), q.Q_ID
                    ) sum
     FROM
         (SELECT Q_ID, Col 
          FROM (SELECT
                    Q_ID
                FROM 
                    utQ
                ) t1
                CROSS JOIN 
               (SELECT 'R' Col
                UNION ALL 
                SELECT 'G' UNION ALL
                SELECT 'B'
               ) t2
          )  q
         LEFT JOIN 
          (SELECT
               v.V_COLOR,
               b.B_Q_ID,
               SUM(b.B_VOL) B_VOL
           FROM
              utB b,utV v
              WHERE v.V_ID = b.B_V_ID  
            GROUP BY 
              v.V_COLOR,
              b.B_Q_ID 
           ) b
         ON q.Q_ID = b.B_Q_ID AND b.V_COLOR = q.Col
     GROUP BY
         q.Q_ID,
         q.col
    ),
--остатки краски по цветам
dsHas AS
    (SELECT
         v.V_COLOR color,
         COUNT(DISTINCT v.V_ID)*255 - SUM(COALESCE(b.B_VOL,0)) has
     FROM
         utV v
         LEFT JOIN utB b
         ON v.V_ID = b.B_V_ID         
     GROUP BY
         v.V_COLOR
     )
SELECT
    DISTINCT dsNeed.Q_ID
FROM 
    dsNeed,
    dsHas
WHERE
    dsNeed.color = dsHas.color and
    dsNeed.sum > dsHas.has

Задание: -1 (Serge I: 2004-06-22) 
Методом наименьших квадратов найти линейную зависимость мгновенного расхода краски от времени: 
V = at + b, 
где V - расход краски; t - время в секундах, отсчитываемое от первой окраски (t = 0). 
Вывод: a с 8-ю знаками после десятичной точки; b - с 2-мя знаками после десятичной точки. 
WITH
dsD AS
(SELECT B_DATETIME,
    iif(DATEDIFF(second,(select min(B_DATETIME) from utB),B_DATETIME)>0,cast(DATEDIFF(second,(select min(B_DATETIME) from utB),B_DATETIME) as decimal(10,0))-81600,0) sec,
    B_VOL vol
 FROM
    utB
),
dsP AS
(SELECT
   SUM(sec * sec) stt,
   SUM(vol * sec)  syt,
   SUM(sec) st,
   SUM(vol)  sy,
   COUNT(*)  N
 FROM
    dsD 
),
d as
(
SELECT (syt * N -sy*st) a ,(N*stt -st*st) b,
 (stt*sy -syt*st) c,(N*stt -st*st) d
FROM
    dsP
)
/*SELECT
   cast(B_DATETIME as int)
 FROM
    dsD*/


select
cast(cast(CONVERT(decimal(30,0), a)  /CONVERT(decimal(30,0),b) as decimal(26,8))as decimal(26,8)) ,
cast(cast(CONVERT(decimal(25,0), c)  /CONVERT(decimal(19,0),b) as decimal(26,1))as decimal(26,2))  from d


***/

Задание: 10 (Serge I: 2017-01-20) 
В таблице utB, отсортированной по b_q_id, b_v_id, b_datetime, определить количество (N) подряд идущих одинаковых значений b_vol от 
конца списка. Вывести N, b_vol.
WITH
   dsV AS
   (SELECT 
        row_number() over ( order by b_q_id, b_v_id, b_datetime) n,
        coalesce(LAG(b_vol) OVER(order by b_q_id, b_v_id, b_datetime),-1) lag,
        b_vol vol    
    FROM 
        utB
   )
SELECT 
   count(*),
   max(vol)
FROM
   dsV v
WHERE 
   n >= (SELECT max(n) FROM dsV where vol <> lag)
