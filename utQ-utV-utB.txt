/***
Схема базы данных состоит из трех отношений:
utQ (Q_ID int, Q_NAME varchar(35)); utV (V_ID int, V_NAME varchar(35), V_COLOR char(1)); utB (B_Q_ID int, B_V_ID int, B_VOL tinyint, B_DATETIME datetime).
Таблица utQ содержит идентификатор и название квадрата, цвет которого первоначально черный.
Таблица utV содержит идентификатор, название и цвет баллончика с краской.
Таблица utB содержит информацию об окраске квадрата баллончиком: идентификатор квадрата, идентификатор баллончика, количество краски и время окраски.
При этом следует иметь в виду, что:
- баллончики с краской могут быть трех цветов - красный V_COLOR='R', зеленый V_COLOR='G', голубой V_COLOR='B' (латинские буквы).
- объем баллончика равен 255 и первоначально он полный;
- цвет квадрата определяется по правилу RGB, т.е. R=0,G=0,B=0 - черный, R=255, G=255, B=255 - белый;
- запись в таблице закрасок utB уменьшает количество краски в баллончике на величину B_VOL и соответственно увеличивает количество краски в квадрате на эту же величину;
- значение 0 < B_VOL <= 255;
- количество краски одного цвета в квадрате не превышает 255, а количество краски в баллончике не может быть меньше нуля;
- время окраски B_DATETIME дано с точностью до секунды, т.е. не содержит миллисекунд.***/

/***
Задание: 92 (ZrenBy: 2003-09-01)
Выбрать все белые квадраты, которые окрашивались только из баллончиков, 
пустых к настоящему времени. Вывести имя квадрата
SELECT DISTINCT q.Q_NAME
FROM utB b, utQ q
WHERE b.B_Q_ID = q.Q_ID and
      b.B_Q_ID in (SELECT B1.B_Q_ID
                   FROM utB b1, utV v1
                   WHERE b1.B_V_ID = v1.V_ID
                   GROUP BY B1.B_Q_ID
                   HAVING sum(iif(v1.V_COLOR = 'R', b1.B_VOL, 0))>=255 and
                          sum(iif(v1.V_COLOR = 'G', b1.B_VOL, 0))>=255 and
                          sum(iif(v1.V_COLOR = 'B', b1.B_VOL, 0))>=255
                  ) and
 b.B_Q_ID not in (SELECT B1.B_Q_ID
                   FROM utB b1, utV v1
                   WHERE b1.B_V_ID = v1.V_ID and
                   v1.V_ID not in (SELECT B2.B_V_ID
                                   FROM utB b2
                                   GROUP BY B2.B_V_ID
                                   HAVING SUM(B2.B_VOL) >= 255
                                  )
                  )

Задание: 106 (Baser: 2013-09-06)
Пусть v1, v2, v3, v4, ... представляет последовательность вещественных чисел - объемов окрасок b_vol, упорядоченных по возрастанию b_datetime, b_q_id, b_v_id. 
Найти преобразованную последовательность P1=v1, P2=v1/v2, P3=v1/v2*v3, P4=v1/v2*v3/v4, ..., где каждый следующий член получается из предыдущего умножением на vi (при нечетных i) или делением на vi (при четных i). 
Результаты представить в виде b_datetime, b_q_id, b_v_id, b_vol, Pi, где Pi - член последовательности, соответствующий номеру записи i. Вывести Pi с 8-ю знаками после запятой.
WITH dsP AS
(SELECT b_datetime, 
        b_q_id, 
        b_v_id, 
        B_VOL,
        ROW_NUMBER() OVER (ORDER BY b_datetime, b_q_id, b_v_id) pow
 FROM utB
)
SELECT b_datetime, 
       b_q_id, 
       b_v_id, 
       B_VOL,
       cast(exp(sum(log(iif(pow % 2 = 0,1.0/cast(B_VOL as decimal(18,8)  ),B_VOL))) OVER (ORDER BY b_datetime, b_q_id, b_v_id)) as decimal(18,8))
FROM dsP
Задание: 116 (Velmont: 2013-11-19)
Считая, что каждая окраска длится ровно секунду, определить непрерывные интервалы времени с длительностью более 1 секунды из таблицы utB.
Вывод: дата первой окраски в интервале, дата последней окраски в интервале.
WITH cte AS (SELECT B_DATETIME, 
	DATEADD(ss, -1 * DENSE_RANK() OVER(ORDER BY B_DATETIME), B_DATETIME) AS grp
	FROM utB
)

SELECT MIN(B_DATETIME), MAX(B_DATETIME)
FROM cte
GROUP BY grp
HAVING COUNT(DISTINCT B_DATETIME) >  1

Задание: 119 ($erges: 2008-04-25)
Сгруппировать все окраски по дням, месяцам и годам. Идентификатор каждой группы должен иметь вид "yyyy" для года, "yyyy-mm" для месяца и "yyyy-mm-dd" для дня.
Вывести только те группы, в которых количество различных моментов времени (b_datetime), когда выполнялась окраска, более 10.
Вывод: идентификатор группы, суммарное количество потраченной краски.
SELECT FORMAT(B_DATETIME, 'yyyy'),
       SUM(B_VOL)
  FROM utB
 GROUP BY FORMAT(B_DATETIME, 'yyyy')
HAVING COUNT(DISTINCT B_DATETIME) > 10
 UNION all
SELECT FORMAT(B_DATETIME, 'yyyy-MM'),
       SUM(B_VOL)      
FROM utB
GROUP BY FORMAT(B_DATETIME, 'yyyy-MM')
HAVING COUNT(DISTINCT B_DATETIME) > 10
     UNION all
SELECT FORMAT(B_DATETIME, 'yyyy-MM-dd'),
       SUM(B_VOL)      
FROM utB
GROUP BY FORMAT(B_DATETIME, 'yyyy-MM-dd')
HAVING COUNT(DISTINCT B_DATETIME) > 10

Задание: 112 (Serge I: 2003-12-24)
Какое максимальное количество черных квадратов можно было бы окрасить в белый цвет
оставшейся краской

with cte as (
select ((count(distinct [V_ID]) * 255 - sum([B_VOL]))/ 255) as fv
from utv left join [dbo].[utB] on [utB].[B_V_ID] = [utV].[V_ID]
group by [V_COLOR])
select iif(count(*)=3,min(fv),0) as qty from cte

Задание: 113 (Serge I: 2003-12-24)
Сколько каждой краски понадобится, чтобы докрасить все Не белые квадраты до белого цвета.
Вывод: количество каждой краски в порядке (R,G,B)
with cte1 as (
select 
     iif(v_color = 'R',
           (select count (*) from utQ) * 255- sum(coalesce([B_VOL],0)),
           0) as r,
     iif(v_color = 'G',
           (select count (*) from utQ) * 255- sum(coalesce([B_VOL],0)),
           0) as g,
     iif(v_color = 'B',
           (select count (*) from utQ) * 255- sum(coalesce([B_VOL],0)),
           0) as b
from utv, utB
where  utb.b_v_ID = utv.v_ID
group by v_color
)
select sum(r), sum(g), sum(b) from cte1

Задание: 115 (Baser: 2013-11-01)
Рассмотрим равнобочные трапеции, в каждую из которых можно вписать касающуюся всех сторон окружность. Кроме того, каждая сторона имеет целочисленную длину из множества значений b_vol. 
Вывести результат в 4 колонки: Up, Down, Side, Rad. Здесь Up - меньшее основание, Down - большее основание, Side - длины боковых сторон, Rad – радиус вписанной окружности (с 2-мя знаками после запятой).
SELECT
    DISTINCT
    b1.b_vol,
    b2.b_vol,
    b3.b_vol,
    CAST(SQRT(1.0 * b1.b_vol * b2.b_vol) / 2 AS NUMERIC(8, 2))
FROM 
    utB b1,
    utB b2,
    utB b3
WHERE 
    b1.b_vol < b2.b_vol and
    b3.b_vol = (1.0 * b1.b_vol + 1.0 * b2.b_vol) / 2

***/
